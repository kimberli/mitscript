void Assembler::adc(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x14);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x15);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x15);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x10);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x10);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc_1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc_1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc_1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x10);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc_1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x10);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc_1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x15);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x10);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc_1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x10);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::adc_1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADC_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x04);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x05);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x05);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x01);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x01);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x01);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x00);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x00);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x01);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add_1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x01);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add_1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x01);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add_1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x00);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add_1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x00);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add_1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x05);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x00);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add_1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x00);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::add_1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADD_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addsubpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSUBPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addsubpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSUBPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addsubps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSUBPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::addsubps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ADDSUBPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesdec(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xde);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESDEC_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesdec(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xde);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESDEC_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesdeclast(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESDECLAST_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesdeclast(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESDECLAST_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesenc(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESENC_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesenc(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESENC_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesenclast(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESENCLAST_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesenclast(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESENCLAST_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesimc(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESIMC_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aesimc(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESIMC_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::aeskeygenassist(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0xdf);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESKEYGENASSIST_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::aeskeygenassist(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0xdf);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AESKEYGENASSIST_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::and_(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x24);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x25);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x25);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x21);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x21);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x21);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x20);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x20);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x21);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and__1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x21);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and__1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x21);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and__1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x20);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and__1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x20);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and__1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x25);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x20);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and__1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and_(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x20);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::and__1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{AND_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andn(const R32& arg0, const R32& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDN_R32_R32_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::andn(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDN_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::andn(const R64& arg0, const R64& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x0,0x1,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDN_R64_R64_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::andn(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x1,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDN_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::andnpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x55);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDNPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andnpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x55);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDNPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andnps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x55);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDNPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andnps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x55);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDNPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x54);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x54);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x54);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::andps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x54);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ANDPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bextr(const R32& arg0, const M32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BEXTR_R32_M32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::bextr(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BEXTR_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::bextr(const R64& arg0, const M64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BEXTR_R64_M64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::bextr(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BEXTR_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendpd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0d);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDPD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendpd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0d);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDPD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendps(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0c);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDPS_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0c);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendvpd(const Xmm& arg0, const M128& arg1, const Xmm0& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x15);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDVPD_XMM_M128_XMM0,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendvpd(const Xmm& arg0, const Xmm& arg1, const Xmm0& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x15);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDVPD_XMM_XMM_XMM0,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendvps(const Xmm& arg0, const M128& arg1, const Xmm0& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x14);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDVPS_XMM_M128_XMM0,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blendvps(const Xmm& arg0, const Xmm& arg1, const Xmm0& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x14);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLENDVPS_XMM_XMM_XMM0,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::blsi(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x0,arg0,arg1,Constants::r64s()[3]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSI_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsi(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x0,arg0,arg1,Constants::r64s()[3]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSI_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsi(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x1,arg0,arg1,Constants::r64s()[3]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSI_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsi(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x1,arg0,arg1,Constants::r64s()[3]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSI_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsmsk(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSMSK_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsmsk(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSMSK_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsmsk(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x1,arg0,arg1,Constants::r64s()[2]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSMSK_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsmsk(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x1,arg0,arg1,Constants::r64s()[2]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSMSK_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsr(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x0,arg0,arg1,Constants::r64s()[1]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSR_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsr(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x0,arg0,arg1,Constants::r64s()[1]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSR_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsr(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x1,arg0,arg1,Constants::r64s()[1]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSR_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::blsr(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x1,arg0,arg1,Constants::r64s()[1]);
  opcode(0xf3);
  mod_rm_sib(arg1,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BLSR_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsf(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSF_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsf(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSF_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsf(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSF_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsf(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSF_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsf(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSF_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsf(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSF_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsr(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSR_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsr(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSR_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsr(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSR_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsr(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSR_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsr(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSR_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bsr(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSR_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bswap(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xc8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSWAP_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::bswap(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xc8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BSWAP_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::bt(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xa3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bt(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xa3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BT_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xbb);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xbb);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xbb);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xbb);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xbb);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btc(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xbb);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTC_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xb3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::btr(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xb3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTR_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xab);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xab);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xab);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xab);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xab);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xba);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bts(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xab);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BTS_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::bzhi(const R32& arg0, const M32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x0,arg2,arg1,arg0);
  opcode(0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BZHI_R32_M32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::bzhi(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x0,arg2,arg1,arg0);
  opcode(0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BZHI_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::bzhi(const R64& arg0, const M64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x0,0x1,arg2,arg1,arg0);
  opcode(0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BZHI_R64_M64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::bzhi(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x0,0x1,arg2,arg1,arg0);
  opcode(0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{BZHI_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::call(const FarPtr1616& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CALL_FARPTR1616,{arg0}}, debug_i);
	#endif
}

void Assembler::call(const FarPtr1632& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CALL_FARPTR1632,{arg0}}, debug_i);
	#endif
}

void Assembler::call(const FarPtr1664& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CALL_FARPTR1664,{arg0}}, debug_i);
	#endif
}

void Assembler::call(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CALL_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::call(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CALL_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::call(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CALL_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::call(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe8);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CALL_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::cbw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x98);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CBW,{}}, debug_i);
	#endif
}

void Assembler::cdq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x99);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CDQ,{}}, debug_i);
	#endif
}

void Assembler::cdqe() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x98);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CDQE,{}}, debug_i);
	#endif
}

void Assembler::clc() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xf8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CLC,{}}, debug_i);
	#endif
}

void Assembler::cld() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xfc);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CLD,{}}, debug_i);
	#endif
}

void Assembler::clflush(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CLFLUSH_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::cli() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xfa);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CLI,{}}, debug_i);
	#endif
}

void Assembler::cmc() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xf5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMC,{}}, debug_i);
	#endif
}

void Assembler::cmova(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVA_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmova(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVA_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmova(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVA_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmova(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVA_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmova(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVA_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmova(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVA_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovae(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVAE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovae(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVAE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovae(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVAE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovae(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVAE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovae(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVAE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovae(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVAE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovb(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVB_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovb(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVB_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovb(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVB_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovb(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVB_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovb(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVB_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovb(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVB_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovbe(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVBE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovbe(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVBE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovbe(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVBE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovbe(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVBE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovbe(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVBE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovbe(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVBE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovc(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVC_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovc(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVC_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovc(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVC_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovc(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVC_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovc(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVC_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovc(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVC_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmove(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmove(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmove(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmove(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmove(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmove(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovg(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVG_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovg(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVG_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovg(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVG_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovg(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVG_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovg(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVG_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovg(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVG_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovge(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVGE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovge(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVGE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovge(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVGE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovge(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVGE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovge(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVGE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovge(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVGE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovl(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVL_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovl(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVL_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovl(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVL_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovl(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVL_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovl(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVL_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovl(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVL_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovle(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVLE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovle(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVLE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovle(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVLE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovle(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVLE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovle(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVLE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovle(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVLE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovna(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNA_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovna(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNA_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovna(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNA_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovna(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNA_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovna(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNA_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovna(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x46);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNA_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnae(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNAE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnae(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNAE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnae(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNAE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnae(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNAE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnae(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNAE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnae(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x42);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNAE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnb(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNB_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnb(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNB_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnb(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNB_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnb(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNB_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnb(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNB_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnb(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNB_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnbe(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNBE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnbe(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNBE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnbe(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNBE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnbe(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNBE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnbe(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNBE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnbe(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x47);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNBE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnc(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNC_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnc(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNC_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnc(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNC_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnc(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNC_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnc(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNC_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnc(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x43);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNC_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovne(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovne(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovne(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovne(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovne(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovne(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovng(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNG_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovng(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNG_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovng(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNG_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovng(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNG_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovng(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNG_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovng(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNG_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnge(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNGE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnge(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNGE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnge(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNGE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnge(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNGE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnge(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNGE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnge(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNGE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnl(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNL_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnl(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNL_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnl(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNL_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnl(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNL_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnl(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNL_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnl(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNL_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnle(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNLE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnle(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNLE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnle(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNLE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnle(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNLE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnle(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNLE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnle(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNLE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovno(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNO_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovno(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNO_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovno(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNO_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovno(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNO_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovno(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNO_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovno(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNO_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnp(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNP_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnp(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNP_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnp(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNP_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnp(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNP_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnp(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNP_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnp(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNP_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovns(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x49);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNS_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovns(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x49);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNS_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovns(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x49);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNS_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovns(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x49);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNS_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovns(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x49);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNS_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovns(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x49);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNS_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnz(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNZ_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnz(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNZ_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnz(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNZ_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnz(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNZ_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnz(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNZ_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovnz(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x45);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVNZ_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovo(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVO_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovo(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVO_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovo(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVO_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovo(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVO_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovo(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVO_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovo(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVO_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovp(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVP_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovp(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVP_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovp(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVP_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovp(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVP_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovp(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVP_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovp(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVP_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpe(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpe(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPE_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpe(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpe(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPE_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpe(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpe(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPE_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpo(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPO_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpo(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPO_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpo(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPO_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpo(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPO_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpo(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPO_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovpo(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x4b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVPO_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovs(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x48);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVS_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovs(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x48);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVS_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovs(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x48);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVS_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovs(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x48);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVS_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovs(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x48);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVS_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovs(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x48);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVS_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovz(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVZ_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovz(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVZ_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovz(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVZ_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovz(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVZ_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovz(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVZ_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmovz(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x44);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMOVZ_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x3c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x3d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x3d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x38);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x38);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp_1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp_1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp_1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x38);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp_1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x38);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp_1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x3d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x38);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp_1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x38);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmp_1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMP_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmppd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPPD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmppd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPPD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmpps(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPPS_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmpps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmps(const M16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPS_M16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmps(const M32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPS_M32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmps(const M64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPS_M64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmps(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPS_M8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpsb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSB,{}}, debug_i);
	#endif
}

void Assembler::cmpsd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSD,{}}, debug_i);
	#endif
}

void Assembler::cmpsd(const Xmm& arg0, const M64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSD_XMM_M64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmpsd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmpsq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSQ,{}}, debug_i);
	#endif
}

void Assembler::cmpss(const Xmm& arg0, const M32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSS_XMM_M32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmpss(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc2);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::cmpsw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPSW,{}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xb1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xb1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xb0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cmpxchg16b(const M128& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xc7);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG16B_M128,{arg0}}, debug_i);
	#endif
}

void Assembler::cmpxchg8b(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xc7);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CMPXCHG8B_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::comisd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{COMISD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::comisd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{COMISD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::comiss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{COMISS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::comiss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{COMISS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cpuid() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xa2);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CPUID,{}}, debug_i);
	#endif
}

void Assembler::cqo() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x99);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CQO,{}}, debug_i);
	#endif
}

void Assembler::crc32(const R32& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R32_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R32& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R32_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R32& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R32_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R32& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R32_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R32& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R32_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R64& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R64_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::crc32(const R64& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CRC32_R64_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtdq2pd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTDQ2PD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtdq2pd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTDQ2PD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtdq2ps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTDQ2PS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtdq2ps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTDQ2PS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpd2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPD2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpd2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPD2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpd2pi(const Mm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPD2PI_MM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpd2pi(const Mm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPD2PI_MM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpd2ps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPD2PS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpd2ps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPD2PS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpi2pd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPI2PD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpi2pd(const Xmm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPI2PD_XMM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpi2ps(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPI2PS_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtpi2ps(const Xmm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPI2PS_XMM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtps2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPS2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtps2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPS2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtps2pd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPS2PD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtps2pd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPS2PD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtps2pi(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPS2PI_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtps2pi(const Mm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTPS2PI_MM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsd2si(const R32& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSD2SI_R32_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsd2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSD2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsd2si(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSD2SI_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsd2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSD2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsd2ss(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSD2SS_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsd2ss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSD2SS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2sd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2sd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2sd(const Xmm& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SD_XMM_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2sd(const Xmm& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SD_XMM_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2ss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2ss(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SS_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2ss(const Xmm& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SS_XMM_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtsi2ss(const Xmm& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSI2SS_XMM_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtss2sd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSS2SD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtss2sd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSS2SD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtss2si(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSS2SI_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtss2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSS2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtss2si(const R64& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSS2SI_R64_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvtss2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTSS2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttpd2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPD2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttpd2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPD2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttpd2pi(const Mm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPD2PI_MM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttpd2pi(const Mm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPD2PI_MM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttps2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPS2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttps2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPS2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttps2pi(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPS2PI_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttps2pi(const Mm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTPS2PI_MM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttsd2si(const R32& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSD2SI_R32_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttsd2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSD2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttsd2si(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSD2SI_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttsd2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSD2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttss2si(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSS2SI_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttss2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSS2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttss2si(const R64& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSS2SI_R64_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cvttss2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CVTTSS2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::cwd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x99);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CWD,{}}, debug_i);
	#endif
}

void Assembler::cwde() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x98);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{CWDE,{}}, debug_i);
	#endif
}

void Assembler::dec(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xfe);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xfe);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::dec(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xfe);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DEC_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::div(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIV_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::divpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::divpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::divps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::divps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::divsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::divsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::divss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::divss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DIVSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::dppd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x41);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DPPD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::dppd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x41);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DPPD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::dpps(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x40);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DPPS_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::dpps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x40);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{DPPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::emms() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x77);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{EMMS,{}}, debug_i);
	#endif
}

void Assembler::enter(const Imm8& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc8);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0,arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ENTER_IMM8_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::enter(const One& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc8);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0,arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ENTER_ONE_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::enter(const Zero& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc8);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0,arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ENTER_ZERO_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::extractps(const M32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x17);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{EXTRACTPS_M32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::extractps(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x17);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{EXTRACTPS_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::extractps(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x17);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{EXTRACTPS_R64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::f2xm1() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{F2XM1,{}}, debug_i);
	#endif
}

void Assembler::fabs() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xe1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FABS,{}}, debug_i);
	#endif
}

void Assembler::fadd(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FADD_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fadd(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FADD_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fadd(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdc,0xc0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FADD_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fadd(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xc0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FADD_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::faddp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xc1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FADDP,{}}, debug_i);
	#endif
}

void Assembler::faddp(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xc0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FADDP_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fbld(const M80Bcd& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FBLD_M80BCD,{arg0}}, debug_i);
	#endif
}

void Assembler::fbstp(const M80Bcd& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FBSTP_M80BCD,{arg0}}, debug_i);
	#endif
}

void Assembler::fchs() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xe0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCHS,{}}, debug_i);
	#endif
}

void Assembler::fclex() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xe2);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCLEX,{}}, debug_i);
	#endif
}

void Assembler::fcmovb(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xda,0xc0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVB_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcmovbe(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xda,0xd0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVBE_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcmove(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xda,0xc8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVE_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcmovnb(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xc0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVNB_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcmovnbe(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xd0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVNBE_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcmovne(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xc8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVNE_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcmovnu(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xd8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVNU_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcmovu(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xda,0xd8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCMOVU_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcom() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xd1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOM,{}}, debug_i);
	#endif
}

void Assembler::fcom(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOM_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fcom(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOM_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fcom(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8,0xd0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOM_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fcomi(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xf0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOMI_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcomip(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdf,0xf0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOMIP_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fcomp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xd9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOMP,{}}, debug_i);
	#endif
}

void Assembler::fcomp(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOMP_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fcomp(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOMP_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fcomp(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8,0xd8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOMP_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fcompp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xd9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOMPP,{}}, debug_i);
	#endif
}

void Assembler::fcos() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xff);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FCOS,{}}, debug_i);
	#endif
}

void Assembler::fdecstp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDECSTP,{}}, debug_i);
	#endif
}

void Assembler::fdiv(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIV_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fdiv(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIV_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fdiv(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdc,0xf0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIV_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fdiv(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xf0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIV_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fdivp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xf1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVP,{}}, debug_i);
	#endif
}

void Assembler::fdivp(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xf0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVP_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fdivr(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVR_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fdivr(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVR_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fdivr(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdc,0xf8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVR_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fdivr(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xf8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVR_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fdivrp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xf9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVRP,{}}, debug_i);
	#endif
}

void Assembler::fdivrp(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xf8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FDIVRP_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ffree(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd,0xc0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FFREE_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fiadd(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIADD_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fiadd(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIADD_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::ficom(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FICOM_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::ficom(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FICOM_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::ficomp(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FICOMP_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::ficomp(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FICOMP_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fidiv(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIDIV_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fidiv(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIDIV_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fidivr(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIDIVR_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fidivr(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIDIVR_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fild(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FILD_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fild(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdb);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FILD_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fild(const M64Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FILD_M64INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fimul(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIMUL_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fimul(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIMUL_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fincstp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FINCSTP,{}}, debug_i);
	#endif
}

void Assembler::finit() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xe3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FINIT,{}}, debug_i);
	#endif
}

void Assembler::fist(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIST_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fist(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdb);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FIST_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fistp(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISTP_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fistp(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdb);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISTP_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fistp(const M64Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISTP_M64INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fisttp(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdf);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISTTP_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fisttp(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdb);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISTTP_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fisttp(const M64Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISTTP_M64INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fisub(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISUB_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fisub(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISUB_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fisubr(const M16Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xde);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISUBR_M16INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fisubr(const M32Int& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xda);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FISUBR_M32INT,{arg0}}, debug_i);
	#endif
}

void Assembler::fld(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLD_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fld(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLD_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fld(const M80Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdb);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLD_M80FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fld(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9,0xc0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLD_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fld1() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xe8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLD1,{}}, debug_i);
	#endif
}

void Assembler::fldcw(const M2Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDCW_M2BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fldenv(const M28Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDENV_M28BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fldl2e() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xea);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDL2E,{}}, debug_i);
	#endif
}

void Assembler::fldl2t() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xe9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDL2T,{}}, debug_i);
	#endif
}

void Assembler::fldlg2() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xec);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDLG2,{}}, debug_i);
	#endif
}

void Assembler::fldln2() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xed);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDLN2,{}}, debug_i);
	#endif
}

void Assembler::fldpi() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xeb);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDPI,{}}, debug_i);
	#endif
}

void Assembler::fldz() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xee);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FLDZ,{}}, debug_i);
	#endif
}

void Assembler::fmul(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FMUL_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fmul(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FMUL_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fmul(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdc,0xc8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FMUL_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fmul(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xc8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FMUL_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fmulp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xc9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FMULP,{}}, debug_i);
	#endif
}

void Assembler::fmulp(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xc8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FMULP_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fnclex() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xe2);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNCLEX,{}}, debug_i);
	#endif
}

void Assembler::fninit() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xe3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNINIT,{}}, debug_i);
	#endif
}

void Assembler::fnop() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xd0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNOP,{}}, debug_i);
	#endif
}

void Assembler::fnsave(const M108Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNSAVE_M108BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fnstcw(const M2Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNSTCW_M2BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fnstenv(const M28Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNSTENV_M28BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fnstsw(const Ax& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdf,0xe0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNSTSW_AX,{arg0}}, debug_i);
	#endif
}

void Assembler::fnstsw(const M2Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FNSTSW_M2BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fpatan() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FPATAN,{}}, debug_i);
	#endif
}

void Assembler::fprem() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FPREM,{}}, debug_i);
	#endif
}

void Assembler::fprem1() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FPREM1,{}}, debug_i);
	#endif
}

void Assembler::fptan() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf2);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FPTAN,{}}, debug_i);
	#endif
}

void Assembler::frndint() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xfc);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FRNDINT,{}}, debug_i);
	#endif
}

void Assembler::frstor(const M108Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FRSTOR_M108BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fsave(const M108Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSAVE_M108BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fscale() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xfd);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSCALE,{}}, debug_i);
	#endif
}

void Assembler::fsin() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xfe);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSIN,{}}, debug_i);
	#endif
}

void Assembler::fsincos() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xfb);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSINCOS,{}}, debug_i);
	#endif
}

void Assembler::fsqrt() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xfa);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSQRT,{}}, debug_i);
	#endif
}

void Assembler::fst(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FST_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fst(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FST_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fst(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd,0xd0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FST_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fstcw(const M2Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTCW_M2BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fstenv(const M28Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTENV_M28BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fstp(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTP_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fstp(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTP_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fstp(const M80Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdb);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTP_M80FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fstp(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd,0xd8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTP_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fstsw(const Ax& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdf,0xe0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTSW_AX,{arg0}}, debug_i);
	#endif
}

void Assembler::fstsw(const M2Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSTSW_M2BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fsub(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUB_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fsub(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUB_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fsub(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdc,0xe0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUB_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fsub(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xe0,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUB_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fsubp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xe1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBP,{}}, debug_i);
	#endif
}

void Assembler::fsubp(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xe0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBP_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fsubr(const M32Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd8);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBR_M32FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fsubr(const M64Fp& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdc);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBR_M64FP,{arg0}}, debug_i);
	#endif
}

void Assembler::fsubr(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdc,0xe8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBR_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fsubr(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd8,0xe8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBR_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fsubrp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xe9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBRP,{}}, debug_i);
	#endif
}

void Assembler::fsubrp(const St& arg0, const St0& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xde,0xe8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FSUBRP_ST_ST0,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ftst() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xe4);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FTST,{}}, debug_i);
	#endif
}

void Assembler::fucom() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdd,0xe1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FUCOM,{}}, debug_i);
	#endif
}

void Assembler::fucom(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd,0xe0,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FUCOM_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fucomi(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdb,0xe8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FUCOMI_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fucomip(const St0& arg0, const St& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdf,0xe8,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FUCOMIP_ST0_ST,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::fucomp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xdd,0xe9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FUCOMP,{}}, debug_i);
	#endif
}

void Assembler::fucomp(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xdd,0xe8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FUCOMP_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fucompp() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xda,0xe9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FUCOMPP,{}}, debug_i);
	#endif
}

void Assembler::fwait() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  // No Opcode Bytes  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FWAIT,{}}, debug_i);
	#endif
}

void Assembler::fxam() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xe5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXAM,{}}, debug_i);
	#endif
}

void Assembler::fxch() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xc9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXCH,{}}, debug_i);
	#endif
}

void Assembler::fxch(const St& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd9,0xc8,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXCH_ST,{arg0}}, debug_i);
	#endif
}

void Assembler::fxrstor(const M512Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXRSTOR_M512BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fxrstor64(const M512Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXRSTOR64_M512BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fxsave(const M512Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXSAVE_M512BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fxsave64(const M512Byte& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXSAVE64_M512BYTE,{arg0}}, debug_i);
	#endif
}

void Assembler::fxtract() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf4);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FXTRACT,{}}, debug_i);
	#endif
}

void Assembler::fyl2x() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FYL2X,{}}, debug_i);
	#endif
}

void Assembler::fyl2xp1() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd9,0xf9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{FYL2XP1,{}}, debug_i);
	#endif
}

void Assembler::haddpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HADDPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::haddpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HADDPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::haddps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HADDPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::haddps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HADDPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::hsubpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HSUBPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::hsubpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HSUBPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::hsubps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HSUBPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::hsubps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{HSUBPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::idiv(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::idiv(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IDIV_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xaf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::imul(const R16& arg0, const M16& arg1, const Imm16& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x69);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R16_M16_IMM16,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R16& arg0, const M16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x6b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R16_M16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xaf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::imul(const R16& arg0, const R16& arg1, const Imm16& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x69);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R16_R16_IMM16,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R16& arg0, const R16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x6b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R16_R16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xaf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::imul(const R32& arg0, const M32& arg1, const Imm32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x69);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R32_M32_IMM32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R32& arg0, const M32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x6b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R32_M32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xaf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::imul(const R32& arg0, const R32& arg1, const Imm32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x69);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R32_R32_IMM32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R32& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x6b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R32_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xaf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::imul(const R64& arg0, const M64& arg1, const Imm32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x69);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R64_M64_IMM32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R64& arg0, const M64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x6b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R64_M64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xaf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::imul(const R64& arg0, const R64& arg1, const Imm32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x69);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R64_R64_IMM32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R64& arg0, const R64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x6b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R64_R64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::imul(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::imul(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IMUL_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::in(const Al& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xec);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IN_AL_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::in(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe4);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IN_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::in(const Ax& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xed);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IN_AX_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::in(const Ax& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe5);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IN_AX_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::in(const Eax& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xed);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IN_EAX_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::in(const Eax& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe5);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IN_EAX_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::inc(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xfe);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xfe);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::inc(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xfe);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INC_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::ins(const M16& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INS_M16_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ins(const M32& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INS_M32_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ins(const M8& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INS_M8_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::insb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INSB,{}}, debug_i);
	#endif
}

void Assembler::insd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INSD,{}}, debug_i);
	#endif
}

void Assembler::insertps(const Xmm& arg0, const M32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x21);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INSERTPS_XMM_M32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::insertps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x21);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INSERTPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::insw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INSW,{}}, debug_i);
	#endif
}

void Assembler::int_(const Imm8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xcd);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INT_IMM8,{arg0}}, debug_i);
	#endif
}

void Assembler::int_(const Three& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xcc);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INT_THREE,{arg0}}, debug_i);
	#endif
}

void Assembler::invpcid(const R64& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x82);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{INVPCID_R64_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::iret() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xcf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IRET,{}}, debug_i);
	#endif
}

void Assembler::iretd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xcf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IRETD,{}}, debug_i);
	#endif
}

void Assembler::iretq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xcf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{IRETQ,{}}, debug_i);
	#endif
}

void Assembler::ja(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::ja_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::ja(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ja_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ja(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::ja(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ja(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::ja(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JA_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jae(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jae_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jae(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jae_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jae(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jae(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jae(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jae(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JAE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jb(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jb_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jb(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jb_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jb(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jb(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jb(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jb(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JB_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jbe(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jbe_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jbe(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jbe_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jbe(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jbe(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jbe(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jbe(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JBE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jc(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jc_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jc(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jc_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jc(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jc(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jc(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jc(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JC_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::je(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::je_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::je(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::je_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::je(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::je(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::je(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::je(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jecxz(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JECXZ_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jecxz(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JECXZ_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jecxz(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JECXZ_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jecxz(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JECXZ_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jg(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jg_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jg(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jg_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jg(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jg(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jg(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jg(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JG_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jge(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jge_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jge(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jge_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jge(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jge(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jge(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jge(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JGE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jl(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jl_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jl(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jl_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jl(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jl(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jl(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jl(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JL_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jle(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jle_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jle(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jle_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jle(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jle(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jle(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jle(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JLE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jmp(const FarPtr1616& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xff);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_FARPTR1616,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp(const FarPtr1632& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xff);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_FARPTR1632,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp(const FarPtr1664& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xff);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_FARPTR1664,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xeb);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe9);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jmp(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xeb);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JMP_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jna(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jna_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jna(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jna_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jna(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jna(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x86);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jna(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jna(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x76);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNA_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnae(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnae_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnae(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnae_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnae(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnae(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x82);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnae(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnae(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x72);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNAE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnb(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnb_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnb(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnb_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnb(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnb(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnb(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnb(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNB_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnbe(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnbe_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnbe(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnbe_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnbe(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnbe(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x87);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnbe(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnbe(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNBE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnc(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnc_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnc(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnc_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnc(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnc(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x83);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnc(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnc(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x73);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNC_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jne(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jne_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jne(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jne_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jne(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jne(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jne(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jne(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jng(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jng_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jng(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jng_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jng(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jng(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jng(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jng(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7e);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNG_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnge(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnge_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnge(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnge_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnge(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnge(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnge(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnge(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNGE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnl(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnl_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnl(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnl_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnl(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnl(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnl(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnl(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNL_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnle(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnle_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnle(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnle_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnle(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnle(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnle(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnle(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7f);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNLE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jno(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x71);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jno_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x81);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jno(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x71);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jno_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x81);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jno(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x81);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jno(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x81);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jno(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x71);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jno(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x71);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNO_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnp(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnp_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnp(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnp_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnp(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnp(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnp(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnp(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNP_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jns(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x79);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jns_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x89);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jns(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x79);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jns_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x89);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jns(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x89);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jns(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x89);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jns(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x79);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jns(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x79);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNS_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnz(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jnz_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jnz(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnz_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnz(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jnz(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x85);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jnz(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jnz(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x75);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JNZ_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jo(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x70);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jo_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x80);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jo(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x70);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jo_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x80);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jo(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x80);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jo(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x80);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jo(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x70);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jo(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x70);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JO_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jp(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jp_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jp(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jp_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jp(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jp(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jp(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jp(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JP_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpe(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jpe_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jpe(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpe_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpe(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jpe(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpe(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jpe(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPE_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpo(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jpo_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jpo(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpo_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpo(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jpo(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x8b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jpo(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jpo(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x7b);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JPO_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jrcxz(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JRCXZ_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jrcxz(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JRCXZ_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jrcxz(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JRCXZ_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jrcxz(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe3);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JRCXZ_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::js(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x78);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::js_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x88);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::js(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x78);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::js_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x88);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::js(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x88);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::js(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x88);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::js(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x78);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::js(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x78);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JS_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jz(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::jz_1(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_LABEL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::jz(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_LABEL_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jz_1(const Label& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_LABEL_HINT_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jz(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::jz(const Rel32& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x84);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_REL32_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::jz(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::jz(const Rel8& arg0, const Hint& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x74);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{JZ_REL8_HINT,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lahf() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x9f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LAHF,{}}, debug_i);
	#endif
}

void Assembler::lar(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LAR_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lar(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LAR_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lar(const R32& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LAR_R32_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lar(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LAR_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lar(const R64& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LAR_R64_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lar(const R64& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LAR_R64_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lddqu(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LDDQU_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ldmxcsr(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LDMXCSR_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::lea(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R16& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R16_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R16& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R16_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R32& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R32_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R32& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R32_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R64& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R64_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R64& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R64_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lea(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x8d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEA_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::leave() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEAVE,{}}, debug_i);
	#endif
}

void Assembler::leave(const Pref66& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LEAVE_PREF66,{arg0}}, debug_i);
	#endif
}

void Assembler::lfence() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xae,0xe8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LFENCE,{}}, debug_i);
	#endif
}

void Assembler::lfs(const R16& arg0, const FarPtr1616& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LFS_R16_FARPTR1616,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lfs(const R32& arg0, const FarPtr1632& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LFS_R32_FARPTR1632,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lfs(const R64& arg0, const FarPtr1664& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LFS_R64_FARPTR1664,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lgs(const R16& arg0, const FarPtr1616& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LGS_R16_FARPTR1616,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lgs(const R32& arg0, const FarPtr1632& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LGS_R32_FARPTR1632,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lgs(const R64& arg0, const FarPtr1664& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LGS_R64_FARPTR1664,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lock() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xf0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LOCK,{}}, debug_i);
	#endif
}

void Assembler::lods(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODS_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::lods(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODS_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::lods(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODS_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::lods(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xac);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::lodsb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xac);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODSB,{}}, debug_i);
	#endif
}

void Assembler::lodsd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODSD,{}}, debug_i);
	#endif
}

void Assembler::lodsq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODSQ,{}}, debug_i);
	#endif
}

void Assembler::lodsw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LODSW,{}}, debug_i);
	#endif
}

void Assembler::loop(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe2);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LOOP_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::loop(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe2);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LOOP_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::loope(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LOOPE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::loope(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LOOPE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::loopne(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label8(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LOOPNE_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::loopne(const Rel8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LOOPNE_REL8,{arg0}}, debug_i);
	#endif
}

void Assembler::lsl(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSL_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lsl(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSL_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lsl(const R32& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSL_R32_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lsl(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSL_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lsl(const R64& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSL_R64_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lsl(const R64& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSL_R64_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lss(const R16& arg0, const FarPtr1616& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSS_R16_FARPTR1616,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lss(const R32& arg0, const FarPtr1632& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSS_R32_FARPTR1632,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lss(const R64& arg0, const FarPtr1664& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LSS_R64_FARPTR1664,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lzcnt(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LZCNT_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lzcnt(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LZCNT_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lzcnt(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LZCNT_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lzcnt(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LZCNT_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lzcnt(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LZCNT_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::lzcnt(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{LZCNT_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maskmovdqu(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MASKMOVDQU_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maskmovq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MASKMOVQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::maxss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MAXSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mfence() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xae,0xf0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MFENCE,{}}, debug_i);
	#endif
}

void Assembler::minpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::minpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::minps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::minps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::minsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::minsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::minss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::minss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MINSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::monitor() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x01,0xc8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MONITOR,{}}, debug_i);
	#endif
}

void Assembler::mov(const Al& arg0, const Moffs8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_AL_MOFFS8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Al& arg0, const Moffs8& arg1, const PrefRexW& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_AL_MOFFS8_PREFREXW,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mov(const Ax& arg0, const Moffs16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa1);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_AX_MOFFS16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Eax& arg0, const Moffs32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa1);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_EAX_MOFFS32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x89);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M16& arg0, const Sreg& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x8c);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M16_SREG,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x89);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x89);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M64& arg0, const Sreg& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x8c);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M64_SREG,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc6);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x88);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x88);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Moffs16& arg0, const Ax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa3);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_MOFFS16_AX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Moffs32& arg0, const Eax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa3);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_MOFFS32_EAX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Moffs64& arg0, const Rax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa3);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_MOFFS64_RAX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Moffs8& arg0, const Al& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa2);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_MOFFS8_AL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Moffs8& arg0, const Al& arg1, const PrefRexW& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa2);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_MOFFS8_AL_PREFREXW,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mov(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xb8,arg0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R16_IMM16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x89);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R16& arg0, const Sreg& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x8c);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R16_SREG,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xb8,arg0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R32_IMM32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x89);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R64& arg0, const Imm64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xb8,arg0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R64_IMM64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x8b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x89);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x8b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R64& arg0, const Sreg& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x8c);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R64_SREG,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xb0,arg0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc6);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R8_IMM8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x88);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x88);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Rax& arg0, const Moffs64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa1);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RAX_MOFFS64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xb0,arg0);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc6);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RH_IMM8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x88);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x88);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov_1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Sreg& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_SREG_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Sreg& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x8e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_SREG_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Sreg& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x8e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_SREG_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mov(const Sreg& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x8e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOV_SREG_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movapd(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPD_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movapd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movapd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movapd_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPD_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movaps(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPS_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movaps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movaps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movaps_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVAPS_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movbe(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVBE_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movbe(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVBE_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movbe(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0x38,0xf1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVBE_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movbe(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVBE_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movbe(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVBE_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movbe(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x38,0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVBE_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const M32& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_M32_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const M32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_M32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const Mm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_MM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const Mm& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_MM_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const R32& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_R32_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movd(const Xmm& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVD_XMM_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movddup(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDDUP_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movddup(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDDUP_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdq2q(const Mm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQ2Q_MM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqa(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQA_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqa(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQA_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqa(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQA_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqa_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQA_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqu(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQU_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqu(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQU_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqu(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQU_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movdqu_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVDQU_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movhlps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVHLPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movhpd(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x17);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVHPD_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movhpd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVHPD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movhps(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x17);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVHPS_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movhps(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVHPS_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movlhps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVLHPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movlpd(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x13);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVLPD_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movlpd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVLPD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movlps(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x13);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVLPS_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movlps(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVLPS_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movmskpd(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVMSKPD_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movmskpd(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVMSKPD_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movmskps(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVMSKPS_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movmskps(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVMSKPS_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movntdq(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xe7);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTDQ_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movntdq(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0xe7);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTDQ_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movntdqa(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTDQA_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movnti(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTI_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movnti(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xc3);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTI_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movntpd(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x2b);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTPD_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movntps(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x2b);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTPS_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movntq(const M64& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xe7);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVNTQ_M64_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const M64& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_M64_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq_1(const M64& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_M64_MM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq_1(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xd6);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_M64_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq_1(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_MM_M64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq_1(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_MM_MM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const Mm& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_MM_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const R64& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_R64_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq_1(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_XMM_M64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const Xmm& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_XMM_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x7e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xd6);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movq2dq(const Xmm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVQ2DQ_XMM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movs(const M16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVS_M16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movs(const M32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVS_M32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movs(const M64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVS_M64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movs(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa4);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVS_M8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa4);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSB,{}}, debug_i);
	#endif
}

void Assembler::movsd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSD,{}}, debug_i);
	#endif
}

void Assembler::movsd(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSD_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsd_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSD_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movshdup(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSHDUP_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movshdup(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSHDUP_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsldup(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSLDUP_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsldup(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSLDUP_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSQ,{}}, debug_i);
	#endif
}

void Assembler::movss(const M32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSS_M32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movss_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSS_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSW,{}}, debug_i);
	#endif
}

void Assembler::movsx(const R16& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R16_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R16& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R16_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R16& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R16_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R32& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R32_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R32& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R32_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R32& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R32_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R32& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R32_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R32& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R32_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R64& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R64_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R64& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R64_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R64& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R64_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsx(const R64& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSX_R64_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsxd(const R64& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x63);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSXD_R64_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movsxd(const R64& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x63);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVSXD_R64_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movupd(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPD_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movupd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movupd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movupd_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPD_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movups(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPS_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movups(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movups(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movups_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVUPS_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R16& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R16_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R16& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R16_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R16& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R16_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R32& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R32_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R32& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R32_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R32& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R32_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R32& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R32_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R32& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R32_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R64& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R64_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R64& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R64_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R64& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R64_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::movzx(const R64& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MOVZX_R64_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mpsadbw(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x42);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MPSADBW_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mpsadbw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x42);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MPSADBW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mul(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::mul(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MUL_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::mulpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::mulx(const R32& arg0, const R32& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULX_R32_R32_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mulx(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULX_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mulx(const R64& arg0, const R64& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x3,0x1,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULX_R64_R64_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mulx(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x3,0x1,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MULX_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::mwait() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x01,0xc9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{MWAIT,{}}, debug_i);
	#endif
}

void Assembler::neg(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::neg(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NEG_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::nop() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x90);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOP,{}}, debug_i);
	#endif
}

void Assembler::nop(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x1f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOP_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::nop(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x1f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOP_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::nop(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x1f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOP_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::nop(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x1f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOP_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::not_(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{NOT_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::or_(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x09);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x09);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x09);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x08);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x08);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x09);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or__1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x09);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or__1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x09);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or__1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x08);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or__1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x08);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or__1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x0d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x08);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or__1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or_(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x08);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::or__1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OR_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::orpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x56);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ORPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::orpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x56);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ORPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::orps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x56);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ORPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::orps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x56);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ORPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::out(const Dx& arg0, const Al& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xee);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUT_DX_AL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::out(const Dx& arg0, const Ax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xef);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUT_DX_AX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::out(const Dx& arg0, const Eax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xef);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUT_DX_EAX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::out(const Imm8& arg0, const Al& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe6);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUT_IMM8_AL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::out(const Imm8& arg0, const Ax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe7);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUT_IMM8_AX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::out(const Imm8& arg0, const Eax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xe7);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUT_IMM8_EAX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::outs(const Dx& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUTS_DX_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::outs(const Dx& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUTS_DX_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::outs(const Dx& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUTS_DX_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::outsb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUTSB,{}}, debug_i);
	#endif
}

void Assembler::outsd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUTSD,{}}, debug_i);
	#endif
}

void Assembler::outsw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{OUTSW,{}}, debug_i);
	#endif
}

void Assembler::pabsb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pabsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PABSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packssdw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSDW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packssdw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSDW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packssdw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSDW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packssdw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSDW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packsswb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x63);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSWB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packsswb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x63);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSWB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packsswb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x63);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSWB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packsswb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x63);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKSSWB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packusdw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKUSDW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packusdw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKUSDW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packuswb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x67);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKUSWB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packuswb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x67);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKUSWB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packuswb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x67);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKUSWB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::packuswb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x67);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PACKUSWB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfe);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddq(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDQ_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xec);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xec);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xec);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xec);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xed);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xed);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xed);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xed);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddusw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDUSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::paddw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfd);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PADDW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::palignr(const Mm& arg0, const M64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0f);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PALIGNR_MM_M64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::palignr(const Mm& arg0, const Mm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0f);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PALIGNR_MM_MM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::palignr(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0f);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PALIGNR_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::palignr(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0f);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PALIGNR_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pand(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAND_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pand(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAND_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pand(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAND_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pand(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAND_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pandn(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PANDN_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pandn(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PANDN_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pandn(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PANDN_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pandn(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xdf);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PANDN_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pause() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0x90);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAUSE,{}}, debug_i);
	#endif
}

void Assembler::pavgb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pavgb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pavgb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pavgb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pavgw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pavgw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pavgw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pavgw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PAVGW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pblendvb(const Xmm& arg0, const M128& arg1, const Xmm0& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PBLENDVB_XMM_M128_XMM0,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pblendvb(const Xmm& arg0, const Xmm& arg1, const Xmm0& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PBLENDVB_XMM_XMM_XMM0,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pblendw(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0e);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PBLENDW_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pblendw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0e);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PBLENDW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pclmulqdq(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x44);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCLMULQDQ_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pclmulqdq(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x44);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCLMULQDQ_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpeqb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x74);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x74);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x74);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x74);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x76);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x76);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x76);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x76);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x29);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x29);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x75);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x75);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x75);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpeqw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x75);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPEQW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpestri(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x61);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPESTRI_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpestri(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x61);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPESTRI_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpestrm(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x60);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPESTRM_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpestrm(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x60);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPESTRM_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpgtb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x64);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x64);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x64);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x64);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x66);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x66);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x66);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x66);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x37);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x37);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x65);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x65);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x65);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpgtw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x65);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPGTW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pcmpistri(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x63);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPISTRI_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpistri(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x63);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPISTRI_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpistrm(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x62);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPISTRM_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pcmpistrm(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x62);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PCMPISTRM_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pdep(const R32& arg0, const R32& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PDEP_R32_R32_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pdep(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PDEP_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pdep(const R64& arg0, const R64& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x3,0x1,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PDEP_R64_R64_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pdep(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x3,0x1,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PDEP_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pext(const R32& arg0, const R32& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXT_R32_R32_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pext(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXT_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pext(const R64& arg0, const R64& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x2,0x1,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXT_R64_R64_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pext(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x2,0x1,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXT_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrb(const M8& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x14);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRB_M8_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrb(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x14);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRB_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrb(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x14);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRB_R64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrd(const M32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRD_M32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrd(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRD_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrq(const M64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0x3a,0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRQ_M64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrq(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0x3a,0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRQ_R64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrw(const M16& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x15);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRW_M16_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrw(const R32& arg0, const Mm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc5);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRW_R32_MM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrw(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc5);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRW_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrw_1(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x15);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRW_R32_XMM_IMM8_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrw(const R64& arg0, const Mm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc5);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRW_R64_MM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrw(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc5);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRW_R64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pextrw_1(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x15);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PEXTRW_R64_XMM_IMM8_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::phaddd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x02);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x03);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x01);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x01);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x01);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phaddw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x01);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHADDW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phminposuw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHMINPOSUW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phminposuw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHMINPOSUW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x06);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x06);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x06);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x06);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x07);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x07);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x07);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x07);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x05);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x05);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x05);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::phsubw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x05);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PHSUBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pinsrb(const Xmm& arg0, const M8& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x20);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRB_XMM_M8_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pinsrb(const Xmm& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x20);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRB_XMM_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pinsrd(const Xmm& arg0, const M32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x22);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRD_XMM_M32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pinsrd(const Xmm& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x22);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRD_XMM_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pinsrw(const Mm& arg0, const M16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc4);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRW_MM_M16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pinsrw(const Mm& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc4);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRW_MM_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pinsrw(const Xmm& arg0, const M16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc4);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRW_XMM_M16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pinsrw(const Xmm& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc4);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PINSRW_XMM_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pmaddubsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x04);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDUBSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaddubsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x04);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDUBSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaddubsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x04);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDUBSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaddubsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x04);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDUBSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaddwd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDWD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaddwd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDWD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaddwd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDWD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaddwd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMADDWD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xee);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xee);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xee);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xee);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxub(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xde);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxub(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xde);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxub(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xde);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxub(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xde);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxud(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxud(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxuw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmaxuw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMAXUW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x38);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x38);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x39);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x39);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xea);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xea);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xea);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xea);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminub(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xda);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminub(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xda);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminub(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xda);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminub(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xda);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminud(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminud(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminuw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pminuw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x3a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMINUW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovmskb(const R32& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVMSKB_R32_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovmskb(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVMSKB_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovmskb(const R64& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVMSKB_R64_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovmskb(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVMSKB_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxbd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x21);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXBD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxbd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x21);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXBD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxbq(const Xmm& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXBQ_XMM_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxbq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXBQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxbw(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x20);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXBW_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxbw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x20);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxdq(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x25);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXDQ_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxdq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x25);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxwd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXWD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxwd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXWD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxwq(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x24);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXWQ_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovsxwq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x24);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVSXWQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxbd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x31);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXBD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxbd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x31);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXBD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxbq(const Xmm& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXBQ_XMM_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxbq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXBQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxbw(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x30);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXBW_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxbw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x30);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxdq(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x35);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXDQ_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxdq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x35);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxwd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXWD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxwd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXWD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxwq(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x34);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXWQ_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmovzxwq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x34);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMOVZXWQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmuldq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULDQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmuldq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhrsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHRSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhrsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHRSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhrsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHRSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhrsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHRSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhuw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHUW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhuw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHUW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhuw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHUW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhuw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHUW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulhw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULHW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulld(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULLD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmulld(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x40);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULLD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmullw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULLW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmullw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULLW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmullw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULLW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmullw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd5);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULLW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmuludq(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULUDQ_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmuludq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULUDQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmuludq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULUDQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pmuludq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf4);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PMULUDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pop(const Fs& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xa1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_FS,{arg0}}, debug_i);
	#endif
}

void Assembler::pop(const Fs& arg0, const Pref66& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xa1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_FS_PREF66,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pop(const Gs& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xa9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_GS,{arg0}}, debug_i);
	#endif
}

void Assembler::pop(const Gs& arg0, const Pref66& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xa9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_GS_PREF66,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pop(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x8f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::pop(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x8f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::pop(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x8f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::pop_1(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x58,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_R16_1,{arg0}}, debug_i);
	#endif
}

void Assembler::pop(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x8f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::pop_1(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x58,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POP_R64_1,{arg0}}, debug_i);
	#endif
}

void Assembler::popcnt(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPCNT_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::popcnt(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPCNT_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::popcnt(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPCNT_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::popcnt(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xb8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPCNT_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::popcnt(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPCNT_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::popcnt(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xb8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPCNT_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::popf() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x9d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPF,{}}, debug_i);
	#endif
}

void Assembler::popfq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x9d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POPFQ,{}}, debug_i);
	#endif
}

void Assembler::por(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xeb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POR_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::por(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xeb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POR_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::por(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xeb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POR_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::por(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xeb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{POR_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::prefetchnta(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x18);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PREFETCHNTA_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::prefetcht0(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x18);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PREFETCHT0_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::prefetcht1(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x18);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PREFETCHT1_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::prefetcht2(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x18);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PREFETCHT2_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::psadbw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSADBW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psadbw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSADBW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psadbw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSADBW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psadbw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSADBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pshufb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x00);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pshufb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x00);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pshufb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x00);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pshufb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x00);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pshufd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pshufd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pshufhw(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFHW_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pshufhw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFHW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pshuflw(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFLW_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pshuflw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFLW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pshufw(const Mm& arg0, const M64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFW_MM_M64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::pshufw(const Mm& arg0, const Mm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSHUFW_MM_MM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::psignb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x08);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x08);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x08);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x08);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGND_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGND_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGND_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x0a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGND_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x09);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x09);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x09);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psignw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x09);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSIGNW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pslld(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x72);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLD_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pslld(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pslld(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pslld(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x72);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLD_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pslld(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pslld(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pslldq(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x73);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLDQ_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllq(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x73);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLQ_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllq(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLQ_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllq(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x73);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLQ_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllw(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x71);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLW_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllw(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x71);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLW_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psllw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSLLW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrad(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x72);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAD_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrad(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrad(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrad(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x72);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAD_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrad(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrad(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psraw(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x71);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAW_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psraw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psraw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psraw(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x71);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAW_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psraw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psraw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRAW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrld(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x72);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLD_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrld(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrld(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrld(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x72);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLD_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrld(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrld(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd2);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrldq(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x73);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLDQ_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlq(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x73);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLQ_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlq(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLQ_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlq(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x73);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLQ_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd3);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlw(const Mm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x71);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLW_MM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlw(const Xmm& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x71);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLW_XMM_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psrlw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd1);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSRLW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfa);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfa);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfa);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfa);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubq(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBQ_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xfb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xe9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusb(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSB_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusb(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSB_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd8);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubusw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xd9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBUSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::psubw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xf9);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PSUBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ptest(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x17);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PTEST_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ptest(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x38,0x17);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PTEST_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhbw(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x68);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHBW_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhbw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x68);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHBW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhbw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x68);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHBW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhbw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x68);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhdq(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHDQ_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhdq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHDQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhdq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHDQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhdq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhqdq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHQDQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhqdq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHQDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhwd(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x69);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHWD_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhwd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x69);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHWD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhwd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x69);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHWD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckhwd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x69);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKHWD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklbw(const Mm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x60);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLBW_MM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklbw(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x60);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLBW_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklbw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x60);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLBW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklbw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x60);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckldq(const Mm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x62);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLDQ_MM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckldq(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x62);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLDQ_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckldq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x62);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLDQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpckldq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x62);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklqdq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLQDQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklqdq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x6c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLQDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklwd(const Mm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x61);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLWD_MM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklwd(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x61);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLWD_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklwd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x61);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLWD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::punpcklwd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x61);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUNPCKLWD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::push(const Fs& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xa0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_FS,{arg0}}, debug_i);
	#endif
}

void Assembler::push(const Gs& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xa8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_GS,{arg0}}, debug_i);
	#endif
}

void Assembler::push(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::push(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::push(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::push_1(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x50,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_R16_1,{arg0}}, debug_i);
	#endif
}

void Assembler::push(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xff);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::push_1(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x50,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSH_R64_1,{arg0}}, debug_i);
	#endif
}

void Assembler::pushf() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x9c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSHF,{}}, debug_i);
	#endif
}

void Assembler::pushfq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x9c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSHFQ,{}}, debug_i);
	#endif
}

void Assembler::pushq(const Imm16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x68);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSHQ_IMM16,{arg0}}, debug_i);
	#endif
}

void Assembler::pushq(const Imm32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x68);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSHQ_IMM32,{arg0}}, debug_i);
	#endif
}

void Assembler::pushq(const Imm8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSHQ_IMM8,{arg0}}, debug_i);
	#endif
}

void Assembler::pushw(const Imm16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x68);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSHW_IMM16,{arg0}}, debug_i);
	#endif
}

void Assembler::pushw(const Imm8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x6a);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PUSHW_IMM8,{arg0}}, debug_i);
	#endif
}

void Assembler::pxor(const Mm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xef);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PXOR_MM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pxor(const Mm& arg0, const Mm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xef);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PXOR_MM_MM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pxor(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xef);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PXOR_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::pxor(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xef);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{PXOR_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcl(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCL_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcpps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCPPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcpps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCPPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcpss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCPSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcpss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCPSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rcr(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RCR_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rdfsbase(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RDFSBASE_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::rdfsbase(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RDFSBASE_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::rdgsbase(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RDGSBASE_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::rdgsbase(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RDGSBASE_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::rdrand(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xc7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RDRAND_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::rdrand(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xc7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RDRAND_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::rdrand(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xc7);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RDRAND_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_ins(const M16& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0x6d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_INS_M16_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_ins(const M32& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0x6d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_INS_M32_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_ins(const M64& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0x6d);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_INS_M64_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_ins(const M8& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0x6c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_INS_M8_DX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_ins_1(const M8& arg0, const Dx& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0x6c);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_INS_M8_DX_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_lods(const Al& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xac);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_LODS_AL,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_lods_1(const Al& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xac);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_LODS_AL_1,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_lods(const Ax& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_LODS_AX,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_lods(const Eax& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_LODS_EAX,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_lods(const Rax& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xad);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_LODS_RAX,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_movs(const M16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_MOVS_M16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_movs(const M32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_MOVS_M32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_movs(const M64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xa5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_MOVS_M64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_movs(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xa4);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_MOVS_M8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_movs_1(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xa4);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_MOVS_M8_M8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_outs(const Dx& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0x6f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_OUTS_DX_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_outs(const Dx& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0x6f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_OUTS_DX_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_outs(const Dx& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0x6f);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_OUTS_DX_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_outs(const Dx& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0x6e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_OUTS_DX_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_outs_1(const Dx& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0x6e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_OUTS_DX_M8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rep_stos(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_STOS_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_stos(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_STOS_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_stos(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_STOS_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_stos(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xaa);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_STOS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::rep_stos_1(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xaa);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REP_STOS_M8_1,{arg0}}, debug_i);
	#endif
}

void Assembler::repe_cmps(const M16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_CMPS_M16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repe_cmps(const M32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_CMPS_M32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repe_cmps(const M64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_CMPS_M64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repe_cmps(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xa6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_CMPS_M8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repe_cmps_1(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xa6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_CMPS_M8_M8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repe_scas(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_SCAS_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::repe_scas(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_SCAS_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::repe_scas(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_SCAS_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::repe_scas(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  opcode(0xae);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_SCAS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::repe_scas_1(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(rex_w());
  opcode(0xae);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPE_SCAS_M8_1,{arg0}}, debug_i);
	#endif
}

void Assembler::repne_cmps(const M16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  pref_group1(0xf2);
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_CMPS_M16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repne_cmps(const M32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  // No REX Prefix
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_CMPS_M32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repne_cmps(const M64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(rex_w());
  opcode(0xa7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_CMPS_M64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repne_cmps(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  // No REX Prefix
  opcode(0xa6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_CMPS_M8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repne_cmps_1(const M8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(rex_w());
  opcode(0xa6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_CMPS_M8_M8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::repne_scas(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  pref_group1(0xf2);
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_SCAS_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::repne_scas(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_SCAS_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::repne_scas(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(rex_w());
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_SCAS_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::repne_scas(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  // No REX Prefix
  opcode(0xae);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_SCAS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::repne_scas_1(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(rex_w());
  opcode(0xae);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{REPNE_SCAS_M8_1,{arg0}}, debug_i);
	#endif
}

void Assembler::ret() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc3);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RET,{}}, debug_i);
	#endif
}

void Assembler::ret(const Far& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xcb);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RET_FAR,{arg0}}, debug_i);
	#endif
}

void Assembler::ret(const Imm16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc2);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RET_IMM16,{arg0}}, debug_i);
	#endif
}

void Assembler::ret(const Imm16& arg0, const Far& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xca);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RET_IMM16_FAR,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rol(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROL_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ror(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[1]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROR_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rorx(const R32& arg0, const M32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xf0);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RORX_R32_M32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::rorx(const R32& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xf0);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RORX_R32_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::rorx(const R64& arg0, const M64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x3,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0xf0);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RORX_R64_M64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::rorx(const R64& arg0, const R64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x3,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0xf0);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RORX_R64_R64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundpd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x09);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDPD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundpd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x09);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDPD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundps(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x08);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDPS_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x08);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundsd(const Xmm& arg0, const M64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDSD_XMM_M64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundsd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0b);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDSD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundss(const Xmm& arg0, const M32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0a);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDSS_XMM_M32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::roundss(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x3a,0x0a);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{ROUNDSS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::rsqrtps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RSQRTPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rsqrtps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RSQRTPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rsqrtss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RSQRTSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::rsqrtss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{RSQRTSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sahf() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x9e);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAHF,{}}, debug_i);
	#endif
}

void Assembler::sal(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sal(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAL_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sar(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[7]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SAR_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sarx(const R32& arg0, const M32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x2,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SARX_R32_M32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::sarx(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x2,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SARX_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::sarx(const R64& arg0, const M64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x2,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SARX_R64_M64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::sarx(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x2,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SARX_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::sbb(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x1c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x1d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x1d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x18);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x18);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb_1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb_1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x1b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb_1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x1b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x18);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb_1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x18);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb_1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x1d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x18);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb_1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x18);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sbb_1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x1a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SBB_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::scas(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCAS_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::scas(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCAS_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::scas(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCAS_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::scas(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xae);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCAS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::scasb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xae);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCASB,{}}, debug_i);
	#endif
}

void Assembler::scasd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCASD,{}}, debug_i);
	#endif
}

void Assembler::scasq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCASQ,{}}, debug_i);
	#endif
}

void Assembler::scasw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xaf);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SCASW,{}}, debug_i);
	#endif
}

void Assembler::seta(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x97);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETA_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::seta(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x97);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETA_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::seta(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x97);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETA_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setae(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETAE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setae(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETAE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setae(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETAE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setb(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETB_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setb(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETB_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setb(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETB_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setbe(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x96);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETBE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setbe(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x96);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETBE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setbe(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x96);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETBE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setc(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETC_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setc(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETC_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setc(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETC_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::sete(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x94);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::sete(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x94);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::sete(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x94);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setg(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETG_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setg(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETG_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setg(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETG_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setge(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9d);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETGE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setge(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9d);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETGE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setge(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9d);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETGE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setl(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9c);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETL_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setl(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9c);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETL_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setl(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9c);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETL_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setle(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9e);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETLE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setle(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9e);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETLE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setle(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9e);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETLE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setna(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x96);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNA_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setna(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x96);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNA_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setna(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x96);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNA_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnae(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNAE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnae(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNAE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnae(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x92);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNAE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnb(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNB_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnb(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNB_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnb(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNB_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnbe(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x97);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNBE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnbe(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x97);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNBE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnbe(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x97);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNBE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnc(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNC_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnc(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNC_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnc(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x93);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNC_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setne(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x95);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setne(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x95);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setne(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x95);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setng(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9e);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNG_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setng(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9e);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNG_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setng(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9e);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNG_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnge(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9c);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNGE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnge(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9c);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNGE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnge(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9c);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNGE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnl(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9d);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNL_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnl(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9d);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNL_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnl(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9d);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNL_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnle(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNLE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnle(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNLE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnle(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9f);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNLE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setno(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x91);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNO_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setno(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x91);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNO_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setno(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x91);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNO_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnp(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9b);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNP_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnp(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9b);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNP_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnp(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9b);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNP_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setns(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x99);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setns(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x99);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNS_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setns(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x99);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNS_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setnz(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x95);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNZ_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnz(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x95);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNZ_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setnz(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x95);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETNZ_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::seto(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x90);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETO_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::seto(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x90);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETO_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::seto(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x90);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETO_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setp(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9a);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETP_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setp(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9a);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETP_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setp(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9a);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETP_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setpe(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9a);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETPE_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setpe(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9a);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETPE_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setpe(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9a);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETPE_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setpo(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9b);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETPO_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setpo(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9b);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETPO_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setpo(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x9b);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETPO_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::sets(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x98);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::sets(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x98);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETS_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::sets(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x98);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETS_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::setz(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x94);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETZ_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::setz(const R8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x94);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETZ_R8,{arg0}}, debug_i);
	#endif
}

void Assembler::setz(const Rh& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x94);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SETZ_RH,{arg0}}, debug_i);
	#endif
}

void Assembler::sfence() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0xae,0xf8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SFENCE,{}}, debug_i);
	#endif
}

void Assembler::shl(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shl(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHL_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shld(const M16& arg0, const R16& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa5);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_M16_R16_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const M16& arg0, const R16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa4);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_M16_R16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const M32& arg0, const R32& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa5);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_M32_R32_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const M32& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa4);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_M32_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const M64& arg0, const R64& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xa5);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_M64_R64_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const M64& arg0, const R64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xa4);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_M64_R64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const R16& arg0, const R16& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa5);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_R16_R16_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const R16& arg0, const R16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa4);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_R16_R16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const R32& arg0, const R32& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa5);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_R32_R32_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const R32& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xa4);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_R32_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const R64& arg0, const R64& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xa5);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_R64_R64_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shld(const R64& arg0, const R64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xa4);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLD_R64_R64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shlx(const R32& arg0, const M32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLX_R32_M32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shlx(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLX_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shlx(const R64& arg0, const M64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLX_R64_M64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shlx(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHLX_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shr(const M16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const M8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_M8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R16& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R16_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R16& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R16_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R32& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R32_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R32& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R32_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R64& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd3);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R64_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xc1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R64& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xd1);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R64_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R8& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R8_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const R8& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_R8_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const Rh& arg0, const Cl& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd2);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_RH_CL,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xc0);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shr(const Rh& arg0, const One& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xd0);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHR_RH_ONE,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::shrd(const M16& arg0, const R16& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xad);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_M16_R16_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const M16& arg0, const R16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xac);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_M16_R16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const M32& arg0, const R32& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xad);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_M32_R32_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const M32& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xac);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_M32_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const M64& arg0, const R64& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xad);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_M64_R64_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const M64& arg0, const R64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xac);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_M64_R64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const R16& arg0, const R16& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xad);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_R16_R16_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const R16& arg0, const R16& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xac);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_R16_R16_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const R32& arg0, const R32& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xad);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_R32_R32_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const R32& arg0, const R32& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xac);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_R32_R32_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const R64& arg0, const R64& arg1, const Cl& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xad);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_R64_R64_CL,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrd(const R64& arg0, const R64& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xac);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRD_R64_R64_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrx(const R32& arg0, const M32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x3,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRX_R32_M32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrx(const R32& arg0, const R32& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x3,0x0,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRX_R32_R32_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrx(const R64& arg0, const M64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x3,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRX_R64_M64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shrx(const R64& arg0, const R64& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x3,0x1,arg2,arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHRX_R64_R64_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shufpd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc6);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHUFPD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shufpd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc6);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHUFPD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shufps(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc6);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHUFPS_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::shufps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xc6);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SHUFPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::sqrtpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sqrtpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sqrtps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sqrtps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sqrtsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sqrtsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sqrtss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sqrtss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SQRTSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::stc() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xf9);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STC,{}}, debug_i);
	#endif
}

void Assembler::std_() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xfd);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STD,{}}, debug_i);
	#endif
}

void Assembler::sti() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xfb);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STI,{}}, debug_i);
	#endif
}

void Assembler::stmxcsr(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STMXCSR_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::stos(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOS_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::stos(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOS_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::stos(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOS_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::stos(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xaa);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOS_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::stosb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xaa);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOSB,{}}, debug_i);
	#endif
}

void Assembler::stosd() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOSD,{}}, debug_i);
	#endif
}

void Assembler::stosq() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOSQ,{}}, debug_i);
	#endif
}

void Assembler::stosw() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xab);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{STOSW,{}}, debug_i);
	#endif
}

void Assembler::sub(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x2c);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x2d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x2d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x28);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x28);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub_1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub_1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub_1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x2b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x28);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub_1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x28);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub_1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x2d);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x28);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub_1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x28);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::sub_1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUB_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::subss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x5c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SUBSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::swapgs() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x01,0xf8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SWAPGS,{}}, debug_i);
	#endif
}

void Assembler::syscall() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x05);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SYSCALL,{}}, debug_i);
	#endif
}

void Assembler::sysenter() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x34);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SYSENTER,{}}, debug_i);
	#endif
}

void Assembler::sysexit() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x35);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SYSEXIT,{}}, debug_i);
	#endif
}

void Assembler::sysexit(const PrefRexW& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x0f,0x35);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SYSEXIT_PREFREXW,{arg0}}, debug_i);
	#endif
}

void Assembler::sysret() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x07);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SYSRET,{}}, debug_i);
	#endif
}

void Assembler::sysret(const PrefRexW& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x0f,0x07);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{SYSRET_PREFREXW,{arg0}}, debug_i);
	#endif
}

void Assembler::test(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa8);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa9);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xa9);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x85);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x85);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x85);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x84);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x84);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x85);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x85);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0xf7);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x85);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x84);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x84);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xa9);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0xf6);
  mod_rm_sib(arg0,Constants::r64s()[0]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x84);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::test(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x84);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TEST_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::tzcnt(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TZCNT_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::tzcnt(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TZCNT_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::tzcnt(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TZCNT_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::tzcnt(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TZCNT_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::tzcnt(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TZCNT_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::tzcnt(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg1,arg0,rex_w());
  opcode(0x0f,0xbc);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{TZCNT_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ucomisd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UCOMISD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ucomisd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UCOMISD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ucomiss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UCOMISS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ucomiss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UCOMISS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::ud2() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x0b);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UD2,{}}, debug_i);
	#endif
}

void Assembler::unpckhpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x15);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKHPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::unpckhpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x15);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKHPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::unpckhps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x15);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKHPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::unpckhps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x15);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKHPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::unpcklpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x14);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKLPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::unpcklpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x14);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKLPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::unpcklps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x14);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKLPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::unpcklps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x14);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{UNPCKLPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vaddpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x58);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x3,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaddsubps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x3,0x0,arg1,arg2,arg0);
  opcode(0xd0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VADDSUBPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesdec(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xde);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESDEC_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesdec(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xde);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESDEC_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesdeclast(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESDECLAST_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesdeclast(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESDECLAST_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesenc(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESENC_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesenc(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESENC_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesenclast(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESENCLAST_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesenclast(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESENCLAST_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaesimc(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESIMC_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vaesimc(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xdb);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESIMC_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vaeskeygenassist(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xdf);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESKEYGENASSIST_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vaeskeygenassist(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xdf);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VAESKEYGENASSIST_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandnps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x55);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDNPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vandps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x54);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VANDPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vblendpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPD_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPD_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPD_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPD_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendps(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPS_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPS_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendps(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPS_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDPS_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Xmm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPD_XMM_XMM_M128_XMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Xmm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPD_XMM_XMM_XMM_XMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Ymm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPD_YMM_YMM_M256_YMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Ymm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPD_YMM_YMM_YMM_YMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvps(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Xmm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPS_XMM_XMM_M128_XMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Xmm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPS_XMM_XMM_XMM_XMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvps(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Ymm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPS_YMM_YMM_M256_YMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vblendvps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Ymm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBLENDVPS_YMM_YMM_YMM_YMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vbroadcastf128(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTF128_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vbroadcasti128(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTI128_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vbroadcastsd(const Ymm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x19);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTSD_YMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vbroadcastsd(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x19);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTSD_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vbroadcastss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x18);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vbroadcastss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x18);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTSS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vbroadcastss(const Ymm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x18);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTSS_YMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vbroadcastss(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x18);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VBROADCASTSS_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcmppd(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPD_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmppd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPD_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmppd(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPD_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmppd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPD_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpps(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPS_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPS_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpps(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPS_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPPS_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPSD_XMM_XMM_M64_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPSD_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpss(const Xmm& arg0, const Xmm& arg1, const M32& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPSS_XMM_XMM_M32_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcmpss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0xc2);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCMPSS_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vcomisd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCOMISD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcomisd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCOMISD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcomiss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCOMISS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcomiss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCOMISS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2pd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2pd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2pd(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PD_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2pd(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PD_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2ps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2ps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2ps(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PS_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtdq2ps(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTDQ2PS_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2dq(const Xmm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2DQ_XMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2dq(const Xmm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2DQ_XMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2ps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2PS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2ps(const Xmm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2PS_XMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2ps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2PS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtpd2ps(const Xmm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPD2PS_XMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtph2ps(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPH2PS_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtph2ps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPH2PS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtph2ps(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPH2PS_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtph2ps(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x13);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPH2PS_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2dq(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2DQ_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2dq(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2DQ_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2pd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2pd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2pd(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PD_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2pd(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PD_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtps2ph(const M128& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x1d);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PH_M128_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtps2ph(const M64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x1d);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PH_M64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtps2ph(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x1d);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PH_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtps2ph(const Xmm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x1d);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTPS2PH_XMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsd2si(const R32& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSD2SI_R32_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtsd2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSD2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtsd2si(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSD2SI_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtsd2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSD2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtsd2ss(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSD2SS_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsd2ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSD2SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2sd(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SD_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x1,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2sd(const Xmm& arg0, const Xmm& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SD_XMM_XMM_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2sd(const Xmm& arg0, const Xmm& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x1,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SD_XMM_XMM_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2ss(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x1,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SS_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2ss(const Xmm& arg0, const Xmm& arg1, const R32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SS_XMM_XMM_R32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtsi2ss(const Xmm& arg0, const Xmm& arg1, const R64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x1,arg1,arg2,arg0);
  opcode(0x2a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSI2SS_XMM_XMM_R64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtss2sd(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSS2SD_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtss2sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSS2SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vcvtss2si(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSS2SI_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtss2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSS2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtss2si(const R64& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSS2SI_R64_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvtss2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTSS2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttpd2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPD2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttpd2dq(const Xmm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPD2DQ_XMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttpd2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPD2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttpd2dq(const Xmm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xe6);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPD2DQ_XMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttps2dq(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPS2DQ_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttps2dq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPS2DQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttps2dq(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPS2DQ_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttps2dq(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x5b);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTPS2DQ_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttsd2si(const R32& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSD2SI_R32_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttsd2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSD2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttsd2si(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSD2SI_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttsd2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSD2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttss2si(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSS2SI_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttss2si(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSS2SI_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttss2si(const R64& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSS2SI_R64_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vcvttss2si(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x2c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VCVTTSS2SI_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vdivpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVSD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdivss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDIVSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vdppd(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x41);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDPPD_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vdppd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x41);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDPPD_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vdpps(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDPPS_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vdpps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDPPS_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vdpps(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDPPS_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vdpps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VDPPS_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::verr(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x00);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VERR_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::verr(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x00);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VERR_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::verw(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x00);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VERW_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::verw(const R16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0x00);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VERW_R16,{arg0}}, debug_i);
	#endif
}

void Assembler::vextractf128(const M128& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VEXTRACTF128_M128_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vextractf128(const Xmm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x19);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VEXTRACTF128_XMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vextracti128(const M128& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VEXTRACTI128_M128_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vextracti128(const Xmm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x39);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VEXTRACTI128_XMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vextractps(const M32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x17);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VEXTRACTPS_M32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vextractps(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x17);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VEXTRACTPS_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x98);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x99);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x99);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x99);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd132ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x99);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD132SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd213ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD213SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmadd231ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADD231SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub132ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x96);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB132PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub213ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB213PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmaddsub231ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMADDSUB231PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub132ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB132SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xaa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xab);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xab);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xab);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub213ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xab);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB213SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xba);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsub231ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUB231SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd132ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x97);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD132PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd213ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xa7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD213PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfmsubadd231ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xb7);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFMSUBADD231PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd132ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD132SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xac);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xad);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xad);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xad);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd213ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xad);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD213SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmadd231ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMADD231SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x9f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub132ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x9f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB132SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xae);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xaf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xaf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xaf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub213ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xaf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB213SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231pd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231pd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231pd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231pd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231ps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231ps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231ps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231ps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231PS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231sd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231SD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231sd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0xbf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231SD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231ss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231SS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vfnmsub231ss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xbf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VFNMSUB231SS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherdpd(const Xmm& arg0, const M32& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x1,arg2,arg1,arg0);
  opcode(0x92);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERDPD_XMM_M32_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherdpd(const Ymm& arg0, const M32& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x1,arg2,arg1,arg0);
  opcode(0x92);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERDPD_YMM_M32_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherdps(const Xmm& arg0, const M32& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,arg2,arg1,arg0);
  opcode(0x92);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERDPS_XMM_M32_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherdps(const Ymm& arg0, const M32& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,arg2,arg1,arg0);
  opcode(0x92);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERDPS_YMM_M32_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherqpd(const Xmm& arg0, const M64& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x1,arg2,arg1,arg0);
  opcode(0x93);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERQPD_XMM_M64_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherqpd(const Ymm& arg0, const M64& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x1,arg2,arg1,arg0);
  opcode(0x93);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERQPD_YMM_M64_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherqps(const Xmm& arg0, const M64& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,arg2,arg1,arg0);
  opcode(0x93);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERQPS_XMM_M64_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vgatherqps_1(const Xmm& arg0, const M64& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,arg2,arg1,arg0);
  opcode(0x93);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VGATHERQPS_XMM_M64_XMM_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhaddps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHADDPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vhsubps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x3,0x0,arg1,arg2,arg0);
  opcode(0x7d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VHSUBPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vinsertf128(const Ymm& arg0, const Ymm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x18);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VINSERTF128_YMM_YMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vinsertf128(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x18);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VINSERTF128_YMM_YMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vinserti128(const Ymm& arg0, const Ymm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x38);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VINSERTI128_YMM_YMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vinserti128(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x38);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VINSERTI128_YMM_YMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vinsertps(const Xmm& arg0, const Xmm& arg1, const M32& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x21);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VINSERTPS_XMM_XMM_M32_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vinsertps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x21);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VINSERTPS_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vlddqu(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VLDDQU_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vlddqu(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xf0);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VLDDQU_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vldmxcsr(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,Constants::r64s()[2]);
  opcode(0xae);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VLDMXCSR_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::vmaskmovdqu(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xf7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVDQU_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmaskmovpd(const M128& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x0,0x1,0x0,arg1,arg0,arg2);
  opcode(0x2f);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPD_M128_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaskmovpd(const M256& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x1,0x1,0x0,arg1,arg0,arg2);
  opcode(0x2f);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPD_M256_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaskmovpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaskmovpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaskmovps(const M128& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x0,0x1,0x0,arg1,arg0,arg2);
  opcode(0x2e);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPS_M128_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaskmovps(const M256& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x1,0x1,0x0,arg1,arg0,arg2);
  opcode(0x2e);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPS_M256_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaskmovps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaskmovps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMASKMOVPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXSD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmaxss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMAXSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINSD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vminss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMINSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovapd(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovapd(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovapd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovapd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovapd_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovapd(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovapd(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovapd_1(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPD_YMM_YMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x28);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovaps_1(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x29);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVAPS_YMM_YMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovd(const M32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVD_M32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovd(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVD_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovd(const Xmm& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVD_XMM_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovddup(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDDUP_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovddup(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDDUP_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovddup(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDDUP_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovddup(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDDUP_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqa_1(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQA_YMM_YMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x6f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovdqu_1(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x7f);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVDQU_YMM_YMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovhlps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x12);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVHLPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovhpd(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x17);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVHPD_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovhpd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x16);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVHPD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovhps(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x17);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVHPS_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovhps(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x16);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVHPS_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovlhps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x16);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVLHPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovlpd(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x13);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVLPD_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovlpd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x12);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVLPD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovlps(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x13);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVLPS_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovlps(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x12);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVLPS_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovmskpd(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPD_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovmskpd(const R32& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPD_R32_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovmskpd(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPD_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovmskpd(const R64& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPD_R64_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovmskps(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPS_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovmskps(const R32& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPS_R32_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovmskps(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPS_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovmskps(const R64& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x50);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVMSKPS_R64_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovntdq(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0xe7);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVNTDQ_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovntdqa(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVNTDQA_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovntdqa(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2a);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVNTDQA_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovntpd(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x2b);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVNTPD_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovntpd(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x2b);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVNTPD_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovntps(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x2b);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVNTPS_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovntps(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x2b);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVNTPS_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x1,Constants::xmm0(),arg0,arg1);
  opcode(0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq_1(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0xd6);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_M64_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x1,Constants::xmm0(),arg0,arg1);
  opcode(0x7e);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq_1(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x7e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_XMM_M64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq(const Xmm& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x6e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_XMM_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x7e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovq_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0xd6);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVQ_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovsd(const M64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSD_M64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovsd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x10);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovsd_1(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg0,arg2);
  opcode(0x11);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSD_XMM_XMM_XMM_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovshdup(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSHDUP_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovshdup(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSHDUP_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovshdup(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSHDUP_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovshdup(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x16);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSHDUP_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovsldup(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSLDUP_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovsldup(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSLDUP_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovsldup(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSLDUP_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovsldup(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x12);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSLDUP_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovss(const M32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSS_M32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x10);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovss_1(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg0,arg2);
  opcode(0x11);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVSS_XMM_XMM_XMM_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmovupd(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovupd(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovupd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovupd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovupd_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovupd(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovupd(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovupd_1(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPD_YMM_YMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups(const M128& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_M128_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups(const M256& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_M256_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups_1(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_XMM_XMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x10);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmovups_1(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x11);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMOVUPS_YMM_YMM_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vmpsadbw(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x42);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMPSADBW_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vmpsadbw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x42);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMPSADBW_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vmpsadbw(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x42);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMPSADBW_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vmpsadbw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x42);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMPSADBW_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vmulpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULSD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vmulss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x59);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VMULSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vorps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x56);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VORPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpabsb(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSB_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsb(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSB_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsb(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1c);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSB_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsd(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSD_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsd(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSD_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsw(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSW_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpabsw(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x1d);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPABSW_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpackssdw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSDW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackssdw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSDW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackssdw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSDW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackssdw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSDW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpacksswb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x63);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSWB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpacksswb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x63);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSWB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpacksswb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x63);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSWB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpacksswb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x63);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKSSWB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackusdw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSDW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackusdw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSDW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackusdw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSDW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackusdw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x2b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSDW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackuswb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x67);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSWB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackuswb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x67);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSWB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackuswb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x67);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSWB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpackuswb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x67);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPACKUSWB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfe);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xec);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xec);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xec);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xec);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xed);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xed);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xed);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddsw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xed);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdc);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddusw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDUSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpaddw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfd);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPADDW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpalignr(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0f);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPALIGNR_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpalignr(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0f);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPALIGNR_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpalignr(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0f);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPALIGNR_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpalignr(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0f);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPALIGNR_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpand(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAND_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpand(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAND_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpand(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAND_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpand(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAND_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpandn(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPANDN_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpandn(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPANDN_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpandn(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPANDN_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpandn(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xdf);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPANDN_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe0);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpavgw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPAVGW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpblendd(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDD_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDD_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendd(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDD_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDD_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendvb(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Xmm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDVB_XMM_XMM_M128_XMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendvb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Xmm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDVB_XMM_XMM_XMM_XMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendvb(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Ymm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDVB_YMM_YMM_M256_YMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendvb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Ymm& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x4c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  disp_imm(arg3);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDVB_YMM_YMM_YMM_YMM,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendw(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0e);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDW_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0e);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDW_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendw(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0e);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDW_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpblendw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0e);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBLENDW_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpbroadcastb(const Xmm& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x78);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTB_XMM_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastb(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x78);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTB_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastb(const Ymm& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x78);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTB_YMM_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastb(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x78);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTB_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastd(const Ymm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTD_YMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastd(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x58);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTD_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastq(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTQ_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastq(const Ymm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTQ_YMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastq(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x59);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTQ_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastw(const Xmm& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x79);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTW_XMM_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x79);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastw(const Ymm& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x79);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTW_YMM_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpbroadcastw(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x79);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPBROADCASTW_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpclmulqdq(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x44);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCLMULQDQ_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpclmulqdq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x44);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCLMULQDQ_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpcmpeqb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x74);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x74);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x74);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x74);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x76);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x76);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x76);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x76);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x29);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x29);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x29);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x29);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x75);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x75);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x75);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpeqw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x75);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPEQW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpestri(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x61);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPESTRI_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpestri(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x61);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPESTRI_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpestrm(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x60);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPESTRM_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpestrm(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x60);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPESTRM_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x64);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x64);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x64);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x64);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x66);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x66);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x66);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x66);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x37);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x37);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x37);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x37);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x65);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x65);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x65);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpgtw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x65);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPGTW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpistri(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x63);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPISTRI_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpistri(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x63);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPISTRI_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpistrm(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x62);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPISTRM_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpcmpistrm(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x62);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPCMPISTRM_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vperm2f128(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x06);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERM2F128_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vperm2f128(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x06);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERM2F128_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vperm2i128(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x46);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERM2I128_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vperm2i128(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x46);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERM2I128_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpermd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x36);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x36);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x05);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x05);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x05);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x05);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x04);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x04);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x04);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x04);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermilps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMILPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermpd(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x1,0x1,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x01);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMPD_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermpd(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x01);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMPD_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x16);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x16);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermq(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x1,0x1,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x00);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMQ_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpermq(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x1,Constants::xmm0(),arg1,arg0);
  opcode(0x00);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPERMQ_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrb(const M8& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x14);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRB_M8_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrb(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x14);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRB_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrb(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x14);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRB_R64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrd(const M32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRD_M32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrd(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRD_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrq(const M64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x0,0x1,0x1,Constants::xmm0(),arg0,arg1);
  opcode(0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRQ_M64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrq(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x1,Constants::xmm0(),arg0,arg1);
  opcode(0x16);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRQ_R64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrw(const M16& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x15);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRW_M16_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrw(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xc5);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRW_R32_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrw_1(const R32& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x15);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRW_R32_XMM_IMM8_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrw(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xc5);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRW_R64_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpextrw_1(const R64& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg0,arg1);
  opcode(0x15);
  mod_rm_sib(arg0,arg1);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPEXTRW_R64_XMM_IMM8_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherdd(const Xmm& arg0, const M32& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,arg2,arg1,arg0);
  opcode(0x90);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERDD_XMM_M32_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherdd(const Ymm& arg0, const M32& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,arg2,arg1,arg0);
  opcode(0x90);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERDD_YMM_M32_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherdq(const Xmm& arg0, const M32& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x1,arg2,arg1,arg0);
  opcode(0x90);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERDQ_XMM_M32_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherdq(const Ymm& arg0, const M32& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x1,arg2,arg1,arg0);
  opcode(0x90);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERDQ_YMM_M32_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherqd(const Xmm& arg0, const M64& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,arg2,arg1,arg0);
  opcode(0x91);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERQD_XMM_M64_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherqd_1(const Xmm& arg0, const M64& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,arg2,arg1,arg0);
  opcode(0x91);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERQD_XMM_M64_XMM_1,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherqq(const Xmm& arg0, const M64& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x1,arg2,arg1,arg0);
  opcode(0x91);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERQQ_XMM_M64_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpgatherqq(const Ymm& arg0, const M64& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x1,arg2,arg1,arg0);
  opcode(0x91);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPGATHERQQ_YMM_M64_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x02);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x03);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x03);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddsw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x03);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddsw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x03);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x01);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x01);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x01);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphaddw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x01);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHADDW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphminposuw(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHMINPOSUW_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vphminposuw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x41);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHMINPOSUW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vphsubd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x06);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x06);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x06);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x06);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x07);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x07);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubsw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x07);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubsw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x07);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x05);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x05);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x05);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vphsubw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x05);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPHSUBW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpinsrb(const Xmm& arg0, const Xmm& arg1, const M8& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x20);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRB_XMM_XMM_M8_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpinsrb(const Xmm& arg0, const Xmm& arg1, const R32& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x20);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRB_XMM_XMM_R32_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpinsrd(const Xmm& arg0, const Xmm& arg1, const M32& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x22);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRD_XMM_XMM_M32_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpinsrd(const Xmm& arg0, const Xmm& arg1, const R32& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x22);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRD_XMM_XMM_R32_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpinsrq(const Xmm& arg0, const Xmm& arg1, const M64& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x22);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRQ_XMM_XMM_M64_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpinsrq(const Xmm& arg0, const Xmm& arg1, const R64& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x22);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRQ_XMM_XMM_R64_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpinsrw(const Xmm& arg0, const Xmm& arg1, const M16& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc4);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRW_XMM_XMM_M16_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpinsrw(const Xmm& arg0, const Xmm& arg1, const R32& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc4);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPINSRW_XMM_XMM_R32_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vpmaddubsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x04);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDUBSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaddubsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x04);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDUBSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaddubsw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x04);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDUBSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaddubsw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x04);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDUBSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaddwd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDWD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaddwd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDWD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaddwd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDWD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaddwd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMADDWD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovd(const M128& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x0,0x1,0x0,arg1,arg0,arg2);
  opcode(0x8e);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVD_M128_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovd(const M256& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x1,0x1,0x0,arg1,arg0,arg2);
  opcode(0x8e);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVD_M256_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x8c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x8c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovq(const M128& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x0,0x1,0x1,arg1,arg0,arg2);
  opcode(0x8e);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVQ_M128_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovq(const M256& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x02,0x1,0x1,0x1,arg1,arg0,arg2);
  opcode(0x8e);
  mod_rm_sib(arg0,arg2);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVQ_M256_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x8c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaskmovq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x8c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMASKMOVQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xee);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xee);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xee);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxsw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xee);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxub(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xde);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxub(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xde);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxub(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xde);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxub(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xde);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxud(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxud(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxud(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxud(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3f);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxuw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxuw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxuw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmaxuw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3e);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMAXUW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x38);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x38);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x38);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x38);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x39);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x39);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x39);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x39);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xea);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xea);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminub(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xda);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminub(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xda);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminub(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xda);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminub(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xda);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminud(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminud(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminud(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminud(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminuw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminuw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminuw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpminuw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x3a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMINUW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmovmskb(const R32& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVMSKB_R32_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovmskb(const R32& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVMSKB_R32_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovmskb(const R64& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVMSKB_R64_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovmskb(const R64& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0xd7);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVMSKB_R64_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x21);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x21);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbd(const Ymm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x21);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBD_YMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbd(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x21);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBD_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbq(const Xmm& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBQ_XMM_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbq(const Ymm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBQ_YMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbq(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x22);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBQ_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbw(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x20);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBW_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x20);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbw(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x20);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBW_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxbw(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x20);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXBW_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxdq(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x25);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXDQ_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxdq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x25);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxdq(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x25);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXDQ_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxdq(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x25);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXDQ_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwd(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWD_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwd(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x23);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWD_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwq(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x24);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWQ_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x24);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwq(const Ymm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x24);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWQ_YMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovsxwq(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x24);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVSXWQ_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbd(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x31);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBD_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x31);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbd(const Ymm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x31);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBD_YMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbd(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x31);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBD_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbq(const Xmm& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBQ_XMM_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbq(const Ymm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBQ_YMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbq(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBQ_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbw(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x30);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBW_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbw(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x30);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBW_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbw(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x30);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBW_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxbw(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x30);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXBW_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxdq(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x35);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXDQ_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxdq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x35);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXDQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxdq(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x35);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXDQ_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxdq(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x35);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXDQ_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwd(const Ymm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWD_YMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwd(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWD_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwq(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x34);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWQ_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwq(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x34);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWQ_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwq(const Ymm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x34);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWQ_YMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmovzxwq(const Ymm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x34);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMOVZXWQ_YMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpmuldq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x28);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULDQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmuldq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x28);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULDQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmuldq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x28);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULDQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmuldq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x28);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULDQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhrsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHRSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhrsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHRSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhrsw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHRSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhrsw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0b);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHRSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhuw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHUW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhuw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHUW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhuw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHUW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhuw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHUW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulhw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULHW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulld(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulld(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulld(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmulld(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x40);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmullw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmullw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmullw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmullw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd5);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULLW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmuludq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULUDQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmuludq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULUDQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmuludq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULUDQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpmuludq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf4);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPMULUDQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpor(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xeb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPOR_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpor(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xeb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPOR_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpor(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xeb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPOR_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpor(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xeb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPOR_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsadbw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSADBW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsadbw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSADBW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsadbw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSADBW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsadbw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf6);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSADBW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x00);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x00);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x00);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x00);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufd(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFD_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufd(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFD_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufhw(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFHW_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufhw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFHW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufhw(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFHW_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshufhw(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x2,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFHW_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshuflw(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFLW_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshuflw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFLW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshuflw(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFLW_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpshuflw(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x3,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x70);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSHUFLW_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsignb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x08);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSIGNB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsignb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x08);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSIGNB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsignd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSIGND_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsignd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSIGND_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsignw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x09);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSIGNW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsignw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x09);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSIGNW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslld(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[6]);
  opcode(0x72);
  mod_rm_sib(arg1,Constants::r64s()[6]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslld(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslld(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslld(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[6]);
  opcode(0x72);
  mod_rm_sib(arg1,Constants::r64s()[6]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLD_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslld(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLD_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslld(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLD_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslldq(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[7]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[7]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLDQ_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpslldq(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[7]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[7]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLDQ_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllq(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[6]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[6]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLQ_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllq(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[6]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[6]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLQ_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllq(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLQ_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllq(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLQ_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllvq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x47);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLVQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[6]);
  opcode(0x71);
  mod_rm_sib(arg1,Constants::r64s()[6]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllw(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[6]);
  opcode(0x71);
  mod_rm_sib(arg1,Constants::r64s()[6]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLW_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllw(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLW_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsllw(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSLLW_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrad(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[4]);
  opcode(0x72);
  mod_rm_sib(arg1,Constants::r64s()[4]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrad(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrad(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrad(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[4]);
  opcode(0x72);
  mod_rm_sib(arg1,Constants::r64s()[4]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAD_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrad(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAD_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrad(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAD_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsravd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x46);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAVD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsravd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x46);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAVD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsravd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x46);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAVD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsravd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x46);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAVD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsraw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[4]);
  opcode(0x71);
  mod_rm_sib(arg1,Constants::r64s()[4]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsraw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsraw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsraw(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[4]);
  opcode(0x71);
  mod_rm_sib(arg1,Constants::r64s()[4]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAW_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsraw(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAW_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsraw(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRAW_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrld(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0x72);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrld(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrld(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrld(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0x72);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLD_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrld(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLD_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrld(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd2);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLD_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrldq(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[3]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[3]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLDQ_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrldq(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[3]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[3]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLDQ_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlq(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLQ_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlq(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0x73);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLQ_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlq(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLQ_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlq(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd3);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLQ_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x1,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlvq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x1,arg1,arg2,arg0);
  opcode(0x45);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLVQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlw(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0x71);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLW_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlw(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg0,arg1,Constants::r64s()[2]);
  opcode(0x71);
  mod_rm_sib(arg1,Constants::r64s()[2]);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLW_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlw(const Ymm& arg0, const Ymm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLW_YMM_YMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsrlw(const Ymm& arg0, const Ymm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd1);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSRLW_YMM_YMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfa);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xfb);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubsw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xe9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusb(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSB_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusb(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSB_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusb(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSB_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusb(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd8);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSB_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubusw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xd9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBUSW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpsubw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xf9);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPSUBW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vptest(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x17);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPTEST_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vptest(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x17);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPTEST_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vptest(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x17);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPTEST_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vptest(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x17);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPTEST_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vpunpckhbw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x68);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHBW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhbw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x68);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHBW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhbw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x68);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHBW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhbw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x68);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHBW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhdq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHDQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhdq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHDQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhdq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHDQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhdq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6a);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHDQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhqdq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHQDQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhqdq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHQDQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhqdq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHQDQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhqdq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6d);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHQDQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhwd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x69);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHWD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhwd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x69);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHWD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhwd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x69);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHWD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckhwd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x69);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKHWD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklbw(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x60);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLBW_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklbw(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x60);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLBW_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklbw(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x60);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLBW_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklbw(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x60);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLBW_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckldq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x62);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLDQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckldq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x62);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLDQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckldq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x62);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLDQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpckldq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x62);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLDQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklqdq(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLQDQ_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklqdq(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLQDQ_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklqdq(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLQDQ_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklqdq(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x6c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLQDQ_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklwd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x61);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLWD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklwd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x61);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLWD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklwd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x61);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLWD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpunpcklwd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x61);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPUNPCKLWD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpxor(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xef);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPXOR_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpxor(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xef);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPXOR_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpxor(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xef);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPXOR_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vpxor(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xef);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VPXOR_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vrcpps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRCPPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrcpps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRCPPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrcpps(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRCPPS_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrcpps(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x53);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRCPPS_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrcpss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x53);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRCPSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vrcpss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x53);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRCPSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundpd(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x09);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPD_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundpd(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x09);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPD_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundpd(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x09);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPD_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundpd(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x09);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPD_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundps(const Xmm& arg0, const M128& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x08);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPS_XMM_M128_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundps(const Xmm& arg0, const Xmm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x08);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPS_XMM_XMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundps(const Ymm& arg0, const M256& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x08);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPS_YMM_M256_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundps(const Ymm& arg0, const Ymm& arg1, const Imm8& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x08);
  mod_rm_sib(arg1,arg0);
  disp_imm(arg2);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDPS_YMM_YMM_IMM8,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vroundsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0b);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDSD_XMM_XMM_M64_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vroundsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0b);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDSD_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vroundss(const Xmm& arg0, const Xmm& arg1, const M32& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0a);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDSS_XMM_XMM_M32_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vroundss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x03,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x0a);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VROUNDSS_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vrsqrtps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRSQRTPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrsqrtps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRSQRTPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrsqrtps(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRSQRTPS_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrsqrtps(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x52);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRSQRTPS_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vrsqrtss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x52);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRSQRTSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vrsqrtss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x52);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VRSQRTSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vshufpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPD_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vshufpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPD_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vshufpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPD_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vshufpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPD_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vshufps(const Xmm& arg0, const Xmm& arg1, const M128& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPS_XMM_XMM_M128_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vshufps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPS_XMM_XMM_XMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vshufps(const Ymm& arg0, const Ymm& arg1, const M256& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPS_YMM_YMM_M256_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vshufps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2, const Imm8& arg3) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0xc6);
  mod_rm_sib(arg2,arg0);
  disp_imm(arg3);
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSHUFPS_YMM_YMM_YMM_IMM8,{arg0,arg1,arg2,arg3}}, debug_i);
	#endif
}

void Assembler::vsqrtpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtpd(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPD_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtpd(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPD_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtps(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPS_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtps(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x51);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTPS_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vsqrtsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x51);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTSD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsqrtsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x51);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsqrtss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x51);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsqrtss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x51);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSQRTSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vstmxcsr(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg0);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg0);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg0,Constants::r64s()[3]);
  opcode(0xae);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSTMXCSR_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::vsubpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubsd(const Xmm& arg0, const Xmm& arg1, const M64& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBSD_XMM_XMM_M64,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubsd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x3,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBSD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubss(const Xmm& arg0, const Xmm& arg1, const M32& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBSS_XMM_XMM_M32,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vsubss(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x2,0x0,arg1,arg2,arg0);
  opcode(0x5c);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VSUBSS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vtestpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vtestpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vtestpd(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPD_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vtestpd(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0f);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPD_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vtestps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vtestps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vtestps(const Ymm& arg0, const M256& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPS_YMM_M256,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vtestps(const Ymm& arg0, const Ymm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x02,0x1,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x0e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VTESTPS_YMM_YMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vucomisd(const Xmm& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUCOMISD_XMM_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vucomisd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUCOMISD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vucomiss(const Xmm& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg1);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg1);
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUCOMISS_XMM_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vucomiss(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0(),arg1,arg0);
  opcode(0x2e);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUCOMISS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::vunpckhpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpckhpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpckhpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpckhpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpckhps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpckhps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpckhps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpckhps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x15);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKHPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vunpcklps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x14);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VUNPCKLPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorpd(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPD_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorpd(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x1,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPD_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorpd(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPD_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorpd(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x1,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPD_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorps(const Xmm& arg0, const Xmm& arg1, const M128& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPS_XMM_XMM_M128,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorps(const Xmm& arg0, const Xmm& arg1, const Xmm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPS_XMM_XMM_XMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorps(const Ymm& arg0, const Ymm& arg1, const M256& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  pref_group2(arg2);
  // Prefix Group 3 is #UD for VEX
  pref_group4(arg2);
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPS_YMM_YMM_M256,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vxorps(const Ymm& arg0, const Ymm& arg1, const Ymm& arg2) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,arg1,arg2,arg0);
  opcode(0x57);
  mod_rm_sib(arg2,arg0);
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VXORPS_YMM_YMM_YMM,{arg0,arg1,arg2}}, debug_i);
	#endif
}

void Assembler::vzeroall() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x1,0x0,0x0,Constants::xmm0());
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VZEROALL,{}}, debug_i);
	#endif
}

void Assembler::vzeroupper() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // VEX-Encoded Instruction: 

  // Prefix Group 1 is #UD for VEX
  // No Prefix Group 2
  // Prefix Group 3 is #UD for VEX
  // No Prefix Group 4
  vex(0x01,0x0,0x0,0x0,Constants::xmm0());
  opcode(0x77);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  // No VEX Immediate
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{VZEROUPPER,{}}, debug_i);
	#endif
}

void Assembler::wait() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  pref_fwait(0x9b);
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  // No Opcode Bytes  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{WAIT,{}}, debug_i);
	#endif
}

void Assembler::wrfsbase(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{WRFSBASE_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::wrfsbase(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[2]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{WRFSBASE_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::wrgsbase(const R32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{WRGSBASE_R32,{arg0}}, debug_i);
	#endif
}

void Assembler::wrgsbase(const R64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[3]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{WRGSBASE_R64,{arg0}}, debug_i);
	#endif
}

void Assembler::xabort(const Imm8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc6,0xf8);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XABORT_IMM8,{arg0}}, debug_i);
	#endif
}

void Assembler::xacquire() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf2);
  // No REX Prefix
  // No Opcode Bytes  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XACQUIRE,{}}, debug_i);
	#endif
}

void Assembler::xadd(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xc1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x0f,0xc1);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xadd(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x0f,0xc0);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XADD_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xbegin(const Label& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc7,0xf8);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  disp_label32(arg0);
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XBEGIN_LABEL,{arg0}}, debug_i);
	#endif
}

void Assembler::xbegin(const Rel32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xc7,0xf8);
  // No MOD R/M or SIB Bytes
  disp_imm(arg0);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XBEGIN_REL32,{arg0}}, debug_i);
	#endif
}

void Assembler::xchg(const Ax& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,(uint8_t)0x00);
  opcode(0x90,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_AX_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const Eax& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,(uint8_t)0x00);
  opcode(0x90,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_EAX_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x87);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R16& arg0, const Ax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x90,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R16_AX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg_1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R32& arg0, const Eax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x90,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R32_EAX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg_1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x87);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x87);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x87);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg_1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x87);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R64& arg0, const Rax& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x90,arg0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R64_RAX,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg_1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg_1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const Rax& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,rex_w());
  opcode(0x90,arg1);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_RAX_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg_1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xchg_1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x86);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XCHG_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xend() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x01,0xd5);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XEND,{}}, debug_i);
	#endif
}

void Assembler::xgetbv() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x01,0xd0);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XGETBV,{}}, debug_i);
	#endif
}

void Assembler::xlat(const M8& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XLAT_M8,{arg0}}, debug_i);
	#endif
}

void Assembler::xlatb() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0xd7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XLATB,{}}, debug_i);
	#endif
}

void Assembler::xlatb_1() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0xd7);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XLATB_1,{}}, debug_i);
	#endif
}

void Assembler::xor_(const Al& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x34);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_AL_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const Ax& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x35);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_AX_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const Eax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x35);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_EAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x31);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x31);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x31);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x30);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const M8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x30);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_M8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R16& arg0, const Imm16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R16_IMM16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R16& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R16_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R16& arg0, const M16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R16_M16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x31);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R16_R16,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor__1(const R16& arg0, const R16& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R16_R16_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R32& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R32_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R32& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R32_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R32& arg0, const M32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R32_M32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x31);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R32_R32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor__1(const R32& arg0, const R32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R32_R32_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R64& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x81);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R64_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R64& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x83);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R64_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R64& arg0, const M64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R64_M64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,rex_w());
  opcode(0x31);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R64_R64,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor__1(const R64& arg0, const R64& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,rex_w());
  opcode(0x33);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R64_R64_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R8& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R8_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R8& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R8_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x30);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R8_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor__1(const R8& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R8_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x30);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R8_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor__1(const R8& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_R8_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const Rax& arg0, const Imm32& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(rex_w());
  opcode(0x35);
  // No MOD R/M or SIB Bytes
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_RAX_IMM32,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const Rh& arg0, const Imm8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x80);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  disp_imm(arg1);
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_RH_IMM8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const Rh& arg0, const M8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_RH_M8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x30);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_RH_R8,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor__1(const Rh& arg0, const R8& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_RH_R8_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor_(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,arg1,(uint8_t)0x00);
  opcode(0x30);
  mod_rm_sib(arg0,arg1);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_RH_RH,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xor__1(const Rh& arg0, const Rh& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x32);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XOR_RH_RH_1,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xorpd(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x57);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XORPD_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xorpd(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  pref_group3();
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x57);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XORPD_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xorps(const Xmm& arg0, const M128& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg1);
  pref_group4(arg1);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x57);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XORPS_XMM_M128,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xorps(const Xmm& arg0, const Xmm& arg1) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg1,arg0,(uint8_t)0x00);
  opcode(0x0f,0x57);
  mod_rm_sib(arg1,arg0);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XORPS_XMM_XMM,{arg0,arg1}}, debug_i);
	#endif
}

void Assembler::xrelease() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  pref_group1(0xf3);
  // No REX Prefix
  // No Opcode Bytes  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XRELEASE,{}}, debug_i);
	#endif
}

void Assembler::xrstor(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XRSTOR_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::xrstor(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XRSTOR_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::xrstor(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XRSTOR_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::xrstor64(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XRSTOR64_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::xrstor64(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XRSTOR64_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::xrstor64(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[5]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XRSTOR64_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::xsave(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVE_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::xsave(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVE_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::xsave(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVE_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::xsave64(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVE64_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::xsave64(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVE64_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::xsave64(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[4]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVE64_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::xsaveopt(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVEOPT_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::xsaveopt(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVEOPT_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::xsaveopt(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,(uint8_t)0x00);
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVEOPT_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::xsaveopt64(const M16& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  pref_group3();
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVEOPT64_M16,{arg0}}, debug_i);
	#endif
}

void Assembler::xsaveopt64(const M32& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVEOPT64_M32,{arg0}}, debug_i);
	#endif
}

void Assembler::xsaveopt64(const M64& arg0) {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  pref_group2(arg0);
  pref_group4(arg0);
  // No Prefix Group 3
  // No Prefix Group 1
  rex(arg0,rex_w());
  opcode(0x0f,0xae);
  mod_rm_sib(arg0,Constants::r64s()[6]);
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XSAVEOPT64_M64,{arg0}}, debug_i);
	#endif
}

void Assembler::xtest() {
	#ifdef DEBUG_ASSEMBLER
		size_t debug_i = fxn_->size();
	#endif

  // Non-VEX-Encoded Instruction: 

  // No FWAIT Prefix
  // No Prefix Group 2
  // No Prefix Group 4
  // No Prefix Group 3
  // No Prefix Group 1
  // No REX Prefix
  opcode(0x0f,0x01,0xd6);
  // No MOD R/M or SIB Bytes
  // No Displacement/Immediate
  // No label displacement
  
	#ifdef DEBUG_ASSEMBLER
		debug(Instruction{XTEST,{}}, debug_i);
	#endif
}
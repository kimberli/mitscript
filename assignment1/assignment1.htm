<html>

<head>
<title>Assignment 1.</title>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" src="library.js"></script>
<link href="style.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1>Assignment 1</h1>

Your goal for this assignment is to create a parser for the MITScript language. 
The grammar for the language is shown below. 

<grammar>
Program ::= Statement* ;;
Statement ::=  Assignment | CallStatement | Global | IfStatement | WhileLoop |  Return;;
Global ::= 'global' name ';' ;;
Assignment ::=  LHS '=' Expression ';' ;;
CallStatement ::= Call ';' ;;
Block ::= '{' Statement* '}';;
IfStatement ::= 'if' '(' Expression ')' Block ( 'else' Block )? ;;
WhileLoop ::= 'while' '(' Expression ')' Block ;;
Return ::= 'return' Expression ;;
;;
Expression ::= Function | Boolean | Record ;;
Function ::= 'fun' '(' Name* ')' Block ;;

Boolean ::= Conjunction ( '|' Conjunction )* ;;
Conjunction ::= BoolUnit ('&amp;' BoolUnit)* ;;
BoolUnit ::= '!'? Predicate ;;
Predicate ::= Arithmetic ( ('&lt;' | '&gt;' | '&lt;=' | '&gt;=') Arithmetic)?
Arithmetic ::= Product ( ('+' | '-') Product)* ;;
Product ::= Unit ( ('*' | '/')  Unit)* ;;
Unit ::= '-'? (LHS | Constant | Call | '(' Boolean ')' );;
LHS ::= Var ('.' Name | '[' Expression ']'  )*  ;;
Call ::= Name '(' (Expression (',' Expression)*)? ')' ;;
Record ::= '{' (Name ':' Expression ';')* '}' ;; 
Constant ::= integer_constant | string_constant
</grammar>

For this exercise, you will create a lexer an a sanner for the language above using the <a href="http://dinosaur.compilertools.net/flex/index.html">flex</a> and <a href="https://www.gnu.org/software/bison/manual/html_node/index.html#SEC_Contents">Bison</a> scanner and parser generators. 
If you are using the course provided VM, both programs are already installed.


There are a number of tutorials on the web, in addition to the instruction manuals linked above.

<p>

The starter code for the lexer sits in a file named "lexer.lex", and the starter code for the parser 
sits in a file called "parser.lex". 

<p>

Your lexer must be able to recognize the following kinds of tokens in addition to all the keywords and operators listed above:
*  integer constants consisting of one or more digits.
*  string constants wrapped in double quotes and supporting the following escaped characters: \\ \" \n \t.
* None constant, equivalent to "NULL" in Java.
* 'true' and 'false'.
*  Name identifiers that start with a letter or underscore, followed by sequence of letters, underscores and numbers. so x0 is a valid variable name, but 0x is not.

 
 
<p>
You need to make sure that all arithmetic operators are left associative, so (w+x+y+z) should be parsed as (((w+x)+y)+z)


<h2>AST</h2>
Your parser must produce an AST with nodes for the following program constructs:
<grammar>
Block ::=  [Statement] ;;
Global ::= name  ;;
Assignment ::=  LHS  Expression  ;;
ExpressionStatement ::= Expression ';' ;;
IfStatement ::= Condition ThenPart ElsePart ;;
WhileLoop ::= Condition Body ;;
Return ::=  Expression ;;
;;
FunctionDeclaration ::= [Arguments] Body ;;
BinaryExpression ::= LeftOperand Operator RightOperand ;;
UnaryExpression ::= Operand Operator ;;
FieldDereference ::= BaseExpression Field ;;
IndexExpression ::= BaseExpression Index  ;;
Call ::= TargetExpression [Arguments] ;;
Record ::= Map[String, Expression]  ;; 
IntegerConstant ;;
StringConstant ;;
NoneConstant ;;
</grammar>


<h2>Deliverables</h2>
Your parser should read a program from the standard input parse it into an AST and pretty print the AST into the screen. 
Specifically, you must: 
* Write the parser and lexer
* Define all the types for your AST nodes
* Define a visitor interface
* Define a PrettyPrinter class that extends the visitor interface and pretty prints the AST. 
We actually don't care that much about how pretty your pretty printer prints. One strict requirement is that your pretty printer should wrap all binary and unary expressions in parenthesis. For unary expressions, the operator should be outside the parenthesis, so !x should be pretty printed to !(x). 
You should also provide 3 tests named test1.mit, test2.mit and test3.mit that your parser can parse correctly. Your tests should provide good coverage of the constructs in the language.


<h2>Implementation notes</h2>
For this assignment, you do not have to worry about reclaiming memory (we will implement garbage collection in a later assignment).

<script>
processDocument();
</script>

</body>



</html>
MITScript a3 submission

## Two assignment parts

Compiler: MITScript → bytecode
Interpreter: bytecode → execution

## How to run stuff

**Bytecode parser**

    make bc-parser
    ./bc-parser ../tests/vm/<test name>.mitbc

**Compiler**

    make compiler
    ./mitscriptc ../tests/vm/<test name>.mit

**Interpreter**

    make interpreter
    ./mitscript -s ../tests/vm/<test name>.mit
    ./mitscript -b ../tests/vm/<test name>.mitbc

**GDB**

    gdb ./mitscriptc
    (in gdb)
    run ../tests/vm/<test name>.mit

    gdb ./mitscript
    (in gdb)
    run -b ../tests/vm/<test name>.mitbc

**Running Tests**

    ../tests/vm/test_compiler.sh (.mit -> .mitbc)
    ../tests/vm/test_vm.sh (.mitbc -> .output)
    ../tests/vm/test_interpreter.sh (.mit -> .output)
    ../tests/vm/test_compiler.sh <test file regex>
    ../tests/vm/test_vm.sh <test file regex>
    ../tests/vm/test_interpreter.sh <test file regex>

## Compiler design
The compiler is designed using the visitor pattern; a BytecodeCompiler Visitor visits each AST node as generated by the MITScript parser in a2 and outputs `Function` and `Instruction` objects as it goes.

It returns a root `Function` object representing the main function of the MITScript program.

Optionally, the `Function` can be pretty-printed out as bytecode (as done in `compiler-main.cpp`).

## 
The interpreter runs in an execution loop, where each instruction is executed in sequence (jumping and calling subfunctions as necessary) until the program is deemed to have terminated.

Its main state is emcompassed in stack frames, represented as `Frame` objects. Datatypes in the program are stored as `Value` objects, where program values are stored in the `Constant` datatype and variable references (used in closures) are stored in `ValWrapper`.
